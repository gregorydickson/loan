---
phase: 12-langextract-advanced-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/extraction/langextract_visualizer.py
  - backend/tests/unit/extraction/test_langextract_visualizer.py
autonomous: true

must_haves:
  truths:
    - "LangExtract generates HTML visualization with highlighted source spans"
    - "Visualization works with LangExtractResult.raw_extractions"
    - "Empty extractions produce placeholder HTML"
  artifacts:
    - path: "backend/src/extraction/langextract_visualizer.py"
      provides: "LangExtractVisualizer class wrapping lx.visualize()"
      exports: ["LangExtractVisualizer"]
      min_lines: 40
    - path: "backend/tests/unit/extraction/test_langextract_visualizer.py"
      provides: "Unit tests for visualization generation"
      min_lines: 30
  key_links:
    - from: "backend/src/extraction/langextract_visualizer.py"
      to: "langextract"
      via: "lx.visualize() call"
      pattern: "lx\\.visualize\\("
---

<objective>
Create LangExtractVisualizer wrapper class for HTML visualization of extraction results.

Purpose: LXTR-07 requires HTML visualization with highlighted source spans. LangExtract's built-in `lx.visualize()` generates this HTML; we wrap it for consistent integration.

Output: LangExtractVisualizer class with generate_html() method, unit tests with mocking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-langextract-advanced-features/12-RESEARCH.md
@backend/src/extraction/langextract_processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LangExtractVisualizer class</name>
  <files>backend/src/extraction/langextract_visualizer.py</files>
  <action>
Create `LangExtractVisualizer` class per 12-RESEARCH.md Pattern 2:

```python
"""LangExtract HTML visualization wrapper.

Generates interactive HTML with highlighted source spans from extraction results.
"""

import langextract as lx
from langextract.core.data import AnnotatedDocument
from pathlib import Path


class LangExtractVisualizer:
    """Generate HTML visualizations of LangExtract extraction results."""

    def generate_html(
        self,
        raw_extractions: AnnotatedDocument | None,
        animation_speed: float = 0.5,
        show_legend: bool = True,
    ) -> str:
        """Generate interactive HTML visualization with highlighted source spans.

        LXTR-07: LangExtract generates HTML visualization with highlighted source spans

        Args:
            raw_extractions: LangExtract AnnotatedDocument result (from LangExtractResult.raw_extractions)
            animation_speed: Seconds between extraction highlights (default 0.5)
            show_legend: Show extraction class color legend (default True)

        Returns:
            HTML string with embedded JavaScript for interactivity
        """
        if not raw_extractions:
            return self._generate_empty_visualization()

        html_obj = lx.visualize(
            data_source=raw_extractions,
            animation_speed=animation_speed,
            show_legend=show_legend,
            gif_optimized=False,  # Not for video capture
        )

        # Handle both Jupyter and standalone contexts
        if hasattr(html_obj, 'data'):
            return html_obj.data
        return str(html_obj)

    def save_html(
        self,
        raw_extractions: AnnotatedDocument | None,
        output_path: Path,
        animation_speed: float = 0.5,
        show_legend: bool = True,
    ) -> None:
        """Generate and save HTML visualization to file.

        Args:
            raw_extractions: LangExtract AnnotatedDocument result
            output_path: Path to write HTML file
            animation_speed: Seconds between extraction highlights
            show_legend: Show extraction class color legend
        """
        html_content = self.generate_html(
            raw_extractions=raw_extractions,
            animation_speed=animation_speed,
            show_legend=show_legend,
        )
        output_path.write_text(html_content)

    def _generate_empty_visualization(self) -> str:
        """Generate placeholder HTML when no extractions exist."""
        return '''<!DOCTYPE html>
<html>
<head>
    <title>Extraction Visualization</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 2rem; }
        .empty { color: #666; text-align: center; margin-top: 4rem; }
    </style>
</head>
<body>
    <div class="empty">
        <h1>No Extractions Found</h1>
        <p>LangExtract did not find any entities in this document.</p>
    </div>
</body>
</html>'''
```

Key points:
- Accept `AnnotatedDocument | None` for safety
- Return empty placeholder HTML if no extractions
- Use `lx.visualize()` with configurable animation_speed and show_legend
- Handle both Jupyter (has .data attribute) and standalone contexts
  </action>
  <verify>
`python -c "from src.extraction.langextract_visualizer import LangExtractVisualizer; v = LangExtractVisualizer(); print(len(v._generate_empty_visualization()))"` shows ~400+ chars.
  </verify>
  <done>LangExtractVisualizer class with generate_html(), save_html(), and empty placeholder</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for LangExtractVisualizer</name>
  <files>backend/tests/unit/extraction/test_langextract_visualizer.py</files>
  <action>
Create test file with mocked tests (no actual LangExtract API calls):

```python
"""Unit tests for LangExtractVisualizer."""

import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock
from src.extraction.langextract_visualizer import LangExtractVisualizer


class TestLangExtractVisualizer:
    """Tests for LangExtractVisualizer."""

    def test_generate_html_with_none_returns_empty_placeholder(self):
        """When raw_extractions is None, return empty placeholder HTML."""
        viz = LangExtractVisualizer()
        html = viz.generate_html(None)
        assert "No Extractions Found" in html
        assert "<html>" in html

    def test_generate_empty_visualization_structure(self):
        """Empty visualization has proper HTML structure."""
        viz = LangExtractVisualizer()
        html = viz._generate_empty_visualization()
        assert "<!DOCTYPE html>" in html
        assert "<html>" in html
        assert "</html>" in html
        assert "No Extractions Found" in html

    @patch("src.extraction.langextract_visualizer.lx")
    def test_generate_html_calls_lx_visualize(self, mock_lx):
        """Verify lx.visualize() is called with correct parameters."""
        mock_result = MagicMock()
        mock_html_obj = MagicMock()
        mock_html_obj.data = "<html>mocked</html>"
        mock_lx.visualize.return_value = mock_html_obj

        viz = LangExtractVisualizer()
        result = viz.generate_html(mock_result, animation_speed=1.0, show_legend=False)

        mock_lx.visualize.assert_called_once_with(
            data_source=mock_result,
            animation_speed=1.0,
            show_legend=False,
            gif_optimized=False,
        )
        assert result == "<html>mocked</html>"

    @patch("src.extraction.langextract_visualizer.lx")
    def test_generate_html_handles_string_return(self, mock_lx):
        """When lx.visualize returns object without .data, use str()."""
        mock_result = MagicMock()
        mock_html_obj = MagicMock(spec=[])  # No .data attribute
        mock_html_obj.__str__ = MagicMock(return_value="<html>string</html>")
        mock_lx.visualize.return_value = mock_html_obj

        viz = LangExtractVisualizer()
        result = viz.generate_html(mock_result)

        assert "<html>string</html>" in result or "string" in str(result)

    @patch("src.extraction.langextract_visualizer.lx")
    def test_generate_html_default_parameters(self, mock_lx):
        """Default animation_speed=0.5 and show_legend=True."""
        mock_result = MagicMock()
        mock_html_obj = MagicMock()
        mock_html_obj.data = "<html></html>"
        mock_lx.visualize.return_value = mock_html_obj

        viz = LangExtractVisualizer()
        viz.generate_html(mock_result)

        mock_lx.visualize.assert_called_once_with(
            data_source=mock_result,
            animation_speed=0.5,
            show_legend=True,
            gif_optimized=False,
        )

    def test_save_html_writes_file(self, tmp_path):
        """save_html() writes HTML content to file."""
        viz = LangExtractVisualizer()
        output_file = tmp_path / "test.html"

        viz.save_html(None, output_file)  # Will use empty placeholder

        assert output_file.exists()
        content = output_file.read_text()
        assert "No Extractions Found" in content

    @patch("src.extraction.langextract_visualizer.lx")
    def test_save_html_with_extractions(self, mock_lx, tmp_path):
        """save_html() writes lx.visualize output to file."""
        mock_result = MagicMock()
        mock_html_obj = MagicMock()
        mock_html_obj.data = "<html>test content</html>"
        mock_lx.visualize.return_value = mock_html_obj

        viz = LangExtractVisualizer()
        output_file = tmp_path / "extraction.html"

        viz.save_html(mock_result, output_file, animation_speed=2.0)

        assert output_file.exists()
        content = output_file.read_text()
        assert content == "<html>test content</html>"
```

8 tests covering:
- None input handling
- Empty visualization structure
- lx.visualize() call with parameters
- Both .data and str() return handling
- Default parameter values
- File saving functionality
  </action>
  <verify>
`cd backend && python -m pytest tests/unit/extraction/test_langextract_visualizer.py -v` - all tests pass.
  </verify>
  <done>8 unit tests for LangExtractVisualizer covering all code paths</done>
</task>

</tasks>

<verification>
- LangExtractVisualizer imports correctly
- generate_html() returns HTML string
- Empty placeholder HTML is valid HTML5
- All tests pass with mocking (no API calls)
</verification>

<success_criteria>
- LXTR-07: LangExtract generates HTML visualization with highlighted source spans
- Visualization works with LangExtractResult.raw_extractions from Phase 11
- `cd backend && python -m pytest tests/unit/extraction/test_langextract_visualizer.py -v` passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-langextract-advanced-features/12-02-SUMMARY.md`
</output>
