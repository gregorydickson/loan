---
phase: 12-langextract-advanced-features
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - backend/src/extraction/extraction_router.py
  - backend/tests/unit/extraction/test_extraction_router.py
autonomous: true

must_haves:
  truths:
    - "LangExtract errors logged with fallback to Docling"
    - "Transient errors (503, 429, timeout) trigger retry with exponential backoff"
    - "Fatal errors immediately fallback without retry"
    - "Method selection works: langextract, docling, or auto"
  artifacts:
    - path: "backend/src/extraction/extraction_router.py"
      provides: "ExtractionRouter with retry and fallback"
      exports: ["ExtractionRouter", "LangExtractTransientError"]
      min_lines: 80
    - path: "backend/tests/unit/extraction/test_extraction_router.py"
      provides: "Unit tests for router, retry, and fallback logic"
      min_lines: 100
  key_links:
    - from: "backend/src/extraction/extraction_router.py"
      to: "backend/src/extraction/langextract_processor.py"
      via: "LangExtractProcessor import and usage"
      pattern: "from.*langextract_processor import LangExtractProcessor"
    - from: "backend/src/extraction/extraction_router.py"
      to: "backend/src/extraction/extractor.py"
      via: "BorrowerExtractor import for fallback"
      pattern: "from.*extractor import BorrowerExtractor"
    - from: "backend/src/extraction/extraction_router.py"
      to: "tenacity"
      via: "retry decorator"
      pattern: "@retry\\("
---

<objective>
Create ExtractionRouter that routes between LangExtract and Docling with tenacity retry and graceful fallback.

Purpose: LXTR-11 requires LangExtract errors to be logged with fallback to Docling extraction. Transient errors (503, 429, timeout) should retry with exponential backoff before falling back.

Output: ExtractionRouter class with method selection, tenacity retry, and fallback logic; comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-langextract-advanced-features/12-RESEARCH.md
@.planning/phases/12-langextract-advanced-features/12-01-PLAN.md
@backend/src/extraction/langextract_processor.py
@backend/src/extraction/extractor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExtractionRouter with tenacity retry</name>
  <files>backend/src/extraction/extraction_router.py</files>
  <action>
Create `ExtractionRouter` per 12-RESEARCH.md Pattern 4:

```python
"""Extraction router with method selection and fallback.

Routes between LangExtract and Docling extraction with retry logic
for transient errors and graceful fallback.
"""

import logging
from typing import Literal
from uuid import UUID

from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
)

from src.extraction.extraction_config import ExtractionConfig
from src.extraction.langextract_processor import LangExtractProcessor, LangExtractResult
from src.extraction.extractor import BorrowerExtractor, ExtractionResult
from src.ingestion.docling_processor import DocumentContent

logger = logging.getLogger(__name__)


class LangExtractTransientError(Exception):
    """Retryable LangExtract error (503, 429, timeout, overloaded)."""
    pass


class LangExtractFatalError(Exception):
    """Non-retryable LangExtract error - triggers immediate fallback."""
    pass


class ExtractionRouter:
    """Routes extraction between LangExtract and Docling with fallback.

    LXTR-11: LangExtract extraction errors logged with fallback to Docling

    Example:
        router = ExtractionRouter(
            langextract_processor=LangExtractProcessor(),
            docling_extractor=BorrowerExtractor(...),
        )
        result = router.extract(document, doc_id, "loan.pdf", method="auto")
    """

    def __init__(
        self,
        langextract_processor: LangExtractProcessor,
        docling_extractor: BorrowerExtractor,
    ):
        """Initialize with both extraction implementations.

        Args:
            langextract_processor: LangExtract-based processor
            docling_extractor: Docling-based BorrowerExtractor
        """
        self.langextract = langextract_processor
        self.docling = docling_extractor

    @retry(
        retry=retry_if_exception_type(LangExtractTransientError),
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=2, min=4, max=60),
    )
    def _try_langextract(
        self,
        document_text: str,
        document_id: UUID,
        document_name: str,
        raw_text: str | None,
        config: ExtractionConfig,
    ) -> LangExtractResult:
        """Attempt LangExtract with retry on transient errors.

        Args:
            document_text: Docling markdown output
            document_id: Document UUID
            document_name: Document filename
            raw_text: Optional raw text for offset translation
            config: Extraction configuration

        Returns:
            LangExtractResult on success

        Raises:
            LangExtractTransientError: For retryable errors (503, 429, timeout)
            LangExtractFatalError: For non-retryable errors
        """
        try:
            return self.langextract.extract(
                document_text=document_text,
                document_id=document_id,
                document_name=document_name,
                raw_text=raw_text,
                config=config,
            )
        except Exception as e:
            error_str = str(e).lower()
            # Classify transient vs fatal errors
            if any(x in error_str for x in ["503", "429", "timeout", "overloaded", "rate limit"]):
                logger.warning(
                    "LangExtract transient error for %s, will retry: %s",
                    document_id, str(e)
                )
                raise LangExtractTransientError(str(e)) from e
            logger.error(
                "LangExtract fatal error for %s: %s",
                document_id, str(e)
            )
            raise LangExtractFatalError(str(e)) from e

    def extract(
        self,
        document: DocumentContent,
        document_id: UUID,
        document_name: str,
        method: Literal["langextract", "docling", "auto"] = "auto",
        config: ExtractionConfig | None = None,
    ) -> ExtractionResult | LangExtractResult:
        """Extract with method selection and fallback.

        LXTR-11: LangExtract extraction errors logged with fallback to Docling

        Args:
            document: Processed document content from Docling
            document_id: Document UUID
            document_name: Document filename
            method: Extraction method:
                - "langextract": LangExtract only (no fallback, raises on error)
                - "docling": Docling only
                - "auto": LangExtract with Docling fallback (default)
            config: Extraction configuration (for langextract)

        Returns:
            ExtractionResult (Docling) or LangExtractResult (LangExtract)
        """
        config = config or ExtractionConfig()

        if method == "docling":
            logger.info("Using Docling extraction for %s", document_id)
            return self.docling.extract(document, document_id, document_name)

        if method == "langextract":
            # LangExtract only - no fallback, will raise on error
            result = self._try_langextract(
                document.text, document_id, document_name, None, config
            )
            logger.info("LangExtract succeeded for %s", document_id)
            return result

        # Auto mode: LangExtract with Docling fallback
        try:
            result = self._try_langextract(
                document.text, document_id, document_name, None, config
            )
            logger.info("LangExtract succeeded for %s (auto mode)", document_id)
            return result
        except (LangExtractTransientError, LangExtractFatalError) as e:
            logger.warning(
                "LangExtract failed for %s after retries: %s. Falling back to Docling.",
                document_id, str(e)
            )
            return self.docling.extract(document, document_id, document_name)
```

Key points:
- Use tenacity @retry decorator with exponential backoff (2, 4, 8... up to 60 seconds)
- Stop after 3 attempts for transient errors
- Classify 503, 429, timeout, overloaded as transient (retry)
- All other errors are fatal (immediate fallback)
- Log all errors with document_id for observability
- method="auto" is default with Docling fallback
  </action>
  <verify>
`python -c "from src.extraction.extraction_router import ExtractionRouter, LangExtractTransientError; print('imports work')"` succeeds.
  </verify>
  <done>ExtractionRouter with tenacity retry, transient/fatal error classification, and Docling fallback</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for ExtractionRouter</name>
  <files>backend/tests/unit/extraction/test_extraction_router.py</files>
  <action>
Create comprehensive unit tests with mocking:

```python
"""Unit tests for ExtractionRouter."""

import pytest
from unittest.mock import MagicMock, patch
from uuid import uuid4

from src.extraction.extraction_router import (
    ExtractionRouter,
    LangExtractTransientError,
    LangExtractFatalError,
)
from src.extraction.extraction_config import ExtractionConfig


class TestExtractionRouter:
    """Tests for ExtractionRouter method selection and fallback."""

    @pytest.fixture
    def mock_langextract(self):
        """Mock LangExtractProcessor."""
        processor = MagicMock()
        processor.extract.return_value = MagicMock(borrowers=[], alignment_warnings=[])
        return processor

    @pytest.fixture
    def mock_docling(self):
        """Mock BorrowerExtractor."""
        extractor = MagicMock()
        extractor.extract.return_value = MagicMock(borrowers=[], validation_errors=[])
        return extractor

    @pytest.fixture
    def mock_document(self):
        """Mock DocumentContent."""
        doc = MagicMock()
        doc.text = "Sample document text"
        return doc

    @pytest.fixture
    def router(self, mock_langextract, mock_docling):
        """Create router with mocked extractors."""
        return ExtractionRouter(mock_langextract, mock_docling)

    def test_method_docling_uses_docling_only(self, router, mock_docling, mock_document):
        """method='docling' uses Docling extractor directly."""
        doc_id = uuid4()
        router.extract(mock_document, doc_id, "test.pdf", method="docling")

        mock_docling.extract.assert_called_once()
        router.langextract.extract.assert_not_called()

    def test_method_langextract_uses_langextract_only(self, router, mock_document):
        """method='langextract' uses LangExtract processor directly."""
        doc_id = uuid4()
        router.extract(mock_document, doc_id, "test.pdf", method="langextract")

        router.langextract.extract.assert_called_once()
        router.docling.extract.assert_not_called()

    def test_method_auto_tries_langextract_first(self, router, mock_document):
        """method='auto' tries LangExtract first."""
        doc_id = uuid4()
        router.extract(mock_document, doc_id, "test.pdf", method="auto")

        router.langextract.extract.assert_called_once()
        router.docling.extract.assert_not_called()  # No fallback needed

    def test_auto_fallback_on_fatal_error(self, router, mock_document):
        """method='auto' falls back to Docling on fatal error."""
        router.langextract.extract.side_effect = Exception("API key invalid")
        doc_id = uuid4()

        router.extract(mock_document, doc_id, "test.pdf", method="auto")

        router.docling.extract.assert_called_once()

    def test_auto_fallback_on_transient_error_after_retries(self, router, mock_document):
        """method='auto' falls back after transient errors exhaust retries."""
        router.langextract.extract.side_effect = Exception("503 Service Unavailable")
        doc_id = uuid4()

        # Should retry 3 times then fallback
        with patch.object(router, '_try_langextract') as mock_try:
            mock_try.side_effect = LangExtractTransientError("503")
            router.extract(mock_document, doc_id, "test.pdf", method="auto")

        router.docling.extract.assert_called_once()

    def test_langextract_only_raises_on_error(self, router, mock_document):
        """method='langextract' raises error without fallback."""
        router.langextract.extract.side_effect = Exception("API error")
        doc_id = uuid4()

        with pytest.raises((LangExtractTransientError, LangExtractFatalError, Exception)):
            router.extract(mock_document, doc_id, "test.pdf", method="langextract")

    def test_config_passed_to_langextract(self, router, mock_document):
        """ExtractionConfig is passed to LangExtract processor."""
        config = ExtractionConfig(extraction_passes=4, max_workers=20)
        doc_id = uuid4()

        router.extract(mock_document, doc_id, "test.pdf", method="langextract", config=config)

        call_kwargs = router.langextract.extract.call_args[1]
        assert call_kwargs["config"] == config

    def test_default_config_when_none(self, router, mock_document):
        """Default ExtractionConfig used when config=None."""
        doc_id = uuid4()

        router.extract(mock_document, doc_id, "test.pdf", method="langextract")

        call_kwargs = router.langextract.extract.call_args[1]
        assert isinstance(call_kwargs["config"], ExtractionConfig)


class TestTransientErrorClassification:
    """Tests for transient vs fatal error classification."""

    def test_503_is_transient(self):
        """503 errors are classified as transient."""
        error = Exception("503 Service Unavailable")
        error_str = str(error).lower()
        assert "503" in error_str

    def test_429_is_transient(self):
        """429 rate limit errors are classified as transient."""
        error = Exception("429 Too Many Requests")
        error_str = str(error).lower()
        assert "429" in error_str

    def test_timeout_is_transient(self):
        """Timeout errors are classified as transient."""
        error = Exception("Request timeout")
        error_str = str(error).lower()
        assert "timeout" in error_str

    def test_overloaded_is_transient(self):
        """Overloaded errors are classified as transient."""
        error = Exception("Model overloaded")
        error_str = str(error).lower()
        assert "overloaded" in error_str

    def test_api_key_invalid_is_fatal(self):
        """API key errors are classified as fatal."""
        error = Exception("API key invalid")
        error_str = str(error).lower()
        # Should not match any transient patterns
        assert not any(x in error_str for x in ["503", "429", "timeout", "overloaded"])


class TestRetryDecorator:
    """Tests for tenacity retry configuration."""

    def test_retry_decorator_on_try_langextract(self):
        """_try_langextract has retry decorator."""
        from src.extraction.extraction_router import ExtractionRouter
        # Check that the method has retry behavior via tenacity
        assert hasattr(ExtractionRouter._try_langextract, 'retry')
```

Tests cover:
- Method selection (docling, langextract, auto)
- Fallback behavior on errors
- Config passing
- Transient vs fatal error classification
- Retry decorator presence
  </action>
  <verify>
`cd backend && python -m pytest tests/unit/extraction/test_extraction_router.py -v` - all tests pass.
  </verify>
  <done>Comprehensive unit tests for ExtractionRouter with 15+ test cases</done>
</task>

</tasks>

<verification>
- ExtractionRouter imports without errors
- Docling fallback works when LangExtract fails
- Transient errors retry up to 3 times
- Fatal errors trigger immediate fallback
- All tests pass with mocking
</verification>

<success_criteria>
- LXTR-11: LangExtract extraction errors logged with fallback to Docling
- Retry logic uses exponential backoff (2, 4, 8... seconds)
- method parameter selects extraction path correctly
- `cd backend && python -m pytest tests/unit/extraction/test_extraction_router.py -v` passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-langextract-advanced-features/12-03-SUMMARY.md`
</output>
