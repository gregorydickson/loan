---
phase: 21-ui-feature-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/api/borrowers.py
  - frontend/src/lib/api/types.ts
  - frontend/src/components/borrowers/source-references.tsx
autonomous: true

must_haves:
  truths:
    - "API returns char_start and char_end fields in source reference response"
    - "Frontend types include char_start and char_end as number | null"
    - "SourceReferences component shows visual indicator (badge) when offsets are present"
  artifacts:
    - path: "backend/src/api/borrowers.py"
      provides: "SourceReferenceResponse with char_start/char_end fields"
      contains: "char_start: int | None"
    - path: "frontend/src/lib/api/types.ts"
      provides: "SourceReference interface with char_start/char_end"
      contains: "char_start: number | null"
    - path: "frontend/src/components/borrowers/source-references.tsx"
      provides: "Visual badge indicator for exact offset extractions"
      contains: "char_start"
  key_links:
    - from: "backend/src/api/borrowers.py"
      to: "frontend/src/lib/api/types.ts"
      via: "API contract match"
      pattern: "char_start.*char_end"
    - from: "frontend/src/lib/api/types.ts"
      to: "frontend/src/components/borrowers/source-references.tsx"
      via: "Type import and usage"
      pattern: "char_start"
---

<objective>
Expose character-level offset fields in API and add visual indicator in frontend.

Purpose: Research identified a critical gap - char_start/char_end are stored in the database but not exposed in the API or used by the frontend. This blocks TEST-07 (character-level offset display/highlighting).

Output: Complete data path from database to UI with visual badge indicator for LangExtract source attribution
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-ui-feature-verification/21-RESEARCH.md
@backend/src/api/borrowers.py
@frontend/src/lib/api/types.ts
@frontend/src/components/borrowers/source-references.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expose char_start/char_end in API response</name>
  <files>backend/src/api/borrowers.py</files>
  <action>
Update SourceReferenceResponse Pydantic model to include character offset fields.

Add these fields to the SourceReferenceResponse class (around line 43-52):
```python
class SourceReferenceResponse(BaseModel):
    """Source reference in borrower response."""

    model_config = ConfigDict(from_attributes=True)

    id: UUID
    document_id: UUID
    page_number: int
    section: str | None
    snippet: str
    char_start: int | None  # ADD THIS
    char_end: int | None    # ADD THIS
```

The database model (storage/models.py) already has these fields with `from_attributes=True` config, so Pydantic will auto-populate from the ORM model.

No changes needed to any endpoint logic - the model_validate calls will automatically include the new fields.
  </action>
  <verify>
Run the backend tests to ensure no regressions:
```bash
cd backend && python -m pytest tests/unit/test_api_borrowers.py -v
```
  </verify>
  <done>
SourceReferenceResponse includes char_start: int | None and char_end: int | None fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Update frontend types and add visual badge indicator</name>
  <files>frontend/src/lib/api/types.ts, frontend/src/components/borrowers/source-references.tsx</files>
  <action>
**Part A: Update TypeScript types (types.ts)**

Add char_start and char_end to the SourceReference interface:
```typescript
export interface SourceReference {
  id: string;
  document_id: string;
  page_number: number;
  section: string | null;
  snippet: string;
  char_start: number | null;  // ADD THIS
  char_end: number | null;    // ADD THIS
}
```

**Part B: Add visual badge indicator in SourceReferences component (source-references.tsx)**

This task implements a VISUAL BADGE INDICATOR (not character-level text highlighting) to differentiate LangExtract results from Docling results. The badge approach is simpler and more reliable because:
- char_start/char_end are positions in the FULL document text, not the snippet
- The snippet is already an excerpt - attempting substring highlighting would be complex and error-prone

Implementation:

1. Add a conditional badge next to snippet display when char_start and char_end are both present:
```tsx
{source.char_start !== null && source.char_end !== null && (
  <span className="inline-flex items-center px-2 py-0.5 text-xs font-medium bg-green-100 text-green-800 rounded ml-2">
    Exact Match
  </span>
)}
```

2. Place the badge in the source reference card, near the snippet or page number

3. Keep existing truncateSnippet behavior for the snippet text itself

This provides clear visual differentiation:
- LangExtract extractions: Show "Exact Match" badge (have char offsets)
- Docling extractions: No badge (char_start/char_end are null)
  </action>
  <verify>
Build the frontend to catch type errors:
```bash
cd frontend && npm run build
```
Run frontend lint:
```bash
cd frontend && npm run lint
```
  </verify>
  <done>
- SourceReference type includes char_start/char_end fields
- SourceReferences component displays "Exact Match" badge when char_start and char_end are present
- No TypeScript or lint errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Redeploy services to production with verified sequencing</name>
  <files>cloudbuild.yaml</files>
  <action>
Deploy backend first, verify success, then deploy frontend. This ensures frontend never runs against an incompatible backend.

**Step 1: Deploy backend and wait for completion**
```bash
cd /Users/gregorydickson/stackpoint/loan
gcloud builds submit --config=backend/cloudbuild.yaml --substitutions=_REGION=us-central1,_SERVICE_NAME=loan-backend-prod,_ENV=prod backend/
```

**Step 2: Verify backend deployment succeeded before proceeding**
```bash
# Wait for the new revision to be serving
BACKEND_URL="https://loan-backend-prod-fjz2snvxjq-uc.a.run.app"

# Health check
curl -sf "$BACKEND_URL/health" || { echo "Backend health check failed - ABORT frontend deployment"; exit 1; }

# Verify new fields are present in API response
BORROWER_ID=$(curl -s "$BACKEND_URL/api/borrowers/" | jq -r '.borrowers[0].id // empty')
if [ -n "$BORROWER_ID" ]; then
  HAS_CHAR_START=$(curl -s "$BACKEND_URL/api/borrowers/$BORROWER_ID" | jq '.source_references[0] | has("char_start")')
  if [ "$HAS_CHAR_START" != "true" ]; then
    echo "Backend API not returning char_start field - ABORT frontend deployment"
    exit 1
  fi
  echo "Backend verification PASSED - char_start/char_end fields present"
else
  echo "No borrowers in database yet - proceeding (new fields will work when data exists)"
fi
```

CRITICAL: Only proceed to Step 3 if Step 2 passes. If backend verification fails, do NOT deploy frontend.

**Step 3: Deploy frontend (only after backend verification passes)**
```bash
cd /Users/gregorydickson/stackpoint/loan
gcloud builds submit --config=frontend/cloudbuild.yaml --substitutions=_REGION=us-central1,_SERVICE_NAME=loan-frontend-prod,_ENV=prod frontend/
```

**Step 4: Final verification**
```bash
# Verify frontend loads
curl -s -o /dev/null -w "%{http_code}" "https://loan-frontend-prod-fjz2snvxjq-uc.a.run.app"
# Expected: 200
```
  </action>
  <verify>
```bash
# Verify backend returns char offsets
BACKEND_URL="https://loan-backend-prod-fjz2snvxjq-uc.a.run.app"
curl -sf "$BACKEND_URL/health" && echo "Backend healthy"

BORROWER_ID=$(curl -s "$BACKEND_URL/api/borrowers/" | jq -r '.borrowers[0].id // empty')
if [ -n "$BORROWER_ID" ]; then
  curl -s "$BACKEND_URL/api/borrowers/$BORROWER_ID" | jq '.source_references[0] | has("char_start")'
  # Expected: true
fi

# Verify frontend loads without errors
curl -s -o /dev/null -w "%{http_code}" "https://loan-frontend-prod-fjz2snvxjq-uc.a.run.app"
# Expected: 200
```
  </verify>
  <done>
- Backend deployment completed and verified (health check passes, char_start field present in API)
- Frontend deployment completed only after backend verification
- Services reachable at production URLs
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. API contract verification:
   ```bash
   BACKEND_URL="https://loan-backend-prod-fjz2snvxjq-uc.a.run.app"
   BORROWER_ID=$(curl -s "$BACKEND_URL/api/borrowers/" | jq -r '.borrowers[0].id')
   curl -s "$BACKEND_URL/api/borrowers/$BORROWER_ID" | jq '.source_references[0]'
   ```
   Response should include char_start and char_end fields (may be null for Docling extractions)

2. Type safety verification:
   ```bash
   cd frontend && npm run build
   ```
   No TypeScript errors related to SourceReference type

3. Production health:
   - Backend: https://loan-backend-prod-fjz2snvxjq-uc.a.run.app/health returns 200
   - Frontend: https://loan-frontend-prod-fjz2snvxjq-uc.a.run.app loads without errors
</verification>

<success_criteria>
- [ ] API includes char_start/char_end in SourceReferenceResponse
- [ ] Frontend types updated to match API contract
- [ ] SourceReferences component shows "Exact Match" badge for LangExtract results with offsets
- [ ] Backend deployed and verified returning new fields before frontend deployment
- [ ] Frontend deployed and rendering without errors
- [ ] TEST-07 (character-level offset display) is now verifiable in Plan 21-02
</success_criteria>

<output>
After completion, create `.planning/phases/21-ui-feature-verification/21-01-SUMMARY.md`
</output>
