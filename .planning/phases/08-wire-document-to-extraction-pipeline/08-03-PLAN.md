---
phase: 08-wire-document-to-extraction-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - backend/tests/integration/test_e2e_extraction.py
  - backend/tests/integration/conftest.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "E2E test uploads document and verifies borrowers are extracted"
    - "Test verifies borrowers appear in GET /api/borrowers/ response"
    - "Test verifies borrower has income records and source references"
    - "Test uses mock LLM but real extraction pipeline"
  artifacts:
    - path: "backend/tests/integration/test_e2e_extraction.py"
      provides: "End-to-end extraction integration tests"
      min_lines: 80
    - path: "backend/tests/integration/conftest.py"
      provides: "mock_borrower_extractor_with_data fixture"
      contains: "mock_borrower_extractor_with_data"
  key_links:
    - from: "backend/tests/integration/test_e2e_extraction.py"
      to: "/api/documents/"
      via: "POST upload"
      pattern: "client.post.*api/documents"
    - from: "backend/tests/integration/test_e2e_extraction.py"
      to: "/api/borrowers/"
      via: "GET list"
      pattern: "client.get.*api/borrowers"
---

<objective>
Create end-to-end integration tests that verify the complete flow: upload document -> extract borrowers -> persist -> retrieve via API.

Purpose: Prove the integration actually works by testing the full pipeline with a mock extractor that returns real borrower data. This validates the Phase 2 -> Phase 3 -> Phase 4 wiring.

Output: Integration tests that verify borrowers extracted from uploaded documents appear in the borrower API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-wire-document-to-extraction-pipeline/08-RESEARCH.md
@.planning/phases/08-wire-document-to-extraction-pipeline/08-02-SUMMARY.md

# Test patterns and fixtures
@backend/tests/integration/conftest.py
@backend/tests/integration/test_e2e_flow.py
@backend/src/models/borrower.py
@backend/src/extraction/extractor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mock extractor fixture that returns borrower data</name>
  <files>backend/tests/integration/conftest.py</files>
  <action>
Add a new fixture that returns a mock BorrowerExtractor configured with realistic test data, for use in E2E extraction tests.

Add after the existing mock_borrower_extractor fixture:

```python
@pytest.fixture
def mock_borrower_extractor_with_data():
    """Create mock BorrowerExtractor that returns realistic borrower data.

    This fixture is used for E2E tests that need to verify borrowers
    are extracted and persisted correctly.
    """
    from decimal import Decimal
    from uuid import uuid4

    from src.extraction import BorrowerExtractor, ExtractionResult
    from src.extraction.complexity_classifier import ComplexityAssessment, ComplexityLevel
    from src.models.borrower import Address, BorrowerRecord, IncomeRecord
    from src.models.document import SourceReference

    # Create test borrower data
    doc_id = uuid4()  # This will be replaced in the test
    test_borrower = BorrowerRecord(
        id=uuid4(),
        name="John Smith",
        ssn="123-45-6789",
        phone="(555) 123-4567",
        email="john.smith@example.com",
        address=Address(
            street="123 Main St",
            city="Austin",
            state="TX",
            zip_code="78701",
        ),
        income_history=[
            IncomeRecord(
                amount=Decimal("75000.00"),
                period="annual",
                year=2024,
                source_type="employment",
                employer="Acme Corp",
            ),
            IncomeRecord(
                amount=Decimal("72000.00"),
                period="annual",
                year=2023,
                source_type="employment",
                employer="Acme Corp",
            ),
        ],
        account_numbers=["1234567890"],
        loan_numbers=["LOAN-2024-001"],
        sources=[],  # Will be populated with correct document_id
        confidence_score=0.85,
    )

    def create_mock_extract(document, document_id, document_name):
        """Create extraction result with document-specific source reference."""
        # Create source reference with actual document_id
        source = SourceReference(
            document_id=document_id,
            document_name=document_name,
            page_number=1,
            snippet="John Smith, SSN: 123-45-6789, employed at Acme Corp",
        )

        # Update borrower with source
        borrower_with_source = BorrowerRecord(
            id=test_borrower.id,
            name=test_borrower.name,
            ssn=test_borrower.ssn,
            phone=test_borrower.phone,
            email=test_borrower.email,
            address=test_borrower.address,
            income_history=test_borrower.income_history,
            account_numbers=test_borrower.account_numbers,
            loan_numbers=test_borrower.loan_numbers,
            sources=[source],
            confidence_score=test_borrower.confidence_score,
        )

        return ExtractionResult(
            borrowers=[borrower_with_source],
            complexity=ComplexityAssessment(
                level=ComplexityLevel.SIMPLE,
                reasons=["Single borrower document"],
                page_count=1,
                indicator_counts={},
            ),
            chunks_processed=1,
            total_tokens=500,
            validation_errors=[],
            consistency_warnings=[],
        )

    extractor = MagicMock(spec=BorrowerExtractor)
    extractor.extract = MagicMock(side_effect=create_mock_extract)
    return extractor
```

This fixture:
- Returns a borrower with all fields populated
- Dynamically creates source reference with correct document_id
- Includes 2 income records for timeline testing
- Has realistic confidence score
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from tests.integration.conftest import *; print('Fixtures importable')"`
Expected: "Fixtures importable" (no import errors)
  </verify>
  <done>
- mock_borrower_extractor_with_data fixture created
- Returns BorrowerRecord with all fields
- Source reference uses actual document_id from extraction call
- Income history has 2 records for timeline testing
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client fixture that uses mock extractor with data</name>
  <files>backend/tests/integration/conftest.py</files>
  <action>
Add a new client fixture that uses mock_borrower_extractor_with_data for E2E extraction tests.

Add after the existing client fixtures:

```python
@pytest.fixture
async def client_with_extraction(
    async_engine, db_session, mock_gcs_client, mock_docling_processor, mock_borrower_extractor_with_data
):
    """Create test client with extractor that returns borrower data.

    Use this fixture for tests that need to verify the full extraction
    pipeline: upload -> extract -> persist -> retrieve.
    """
    session_factory = async_sessionmaker(
        async_engine,
        class_=AsyncSession,
        expire_on_commit=False,
    )

    async def override_get_db_session():
        async with session_factory() as session:
            try:
                yield session
                await session.commit()
            except Exception:
                await session.rollback()
                raise

    def override_get_gcs_client():
        return mock_gcs_client

    def override_get_docling_processor():
        return mock_docling_processor

    def override_get_borrower_extractor():
        return mock_borrower_extractor_with_data

    app.dependency_overrides[get_db_session] = override_get_db_session
    app.dependency_overrides[get_gcs_client] = override_get_gcs_client
    app.dependency_overrides[get_docling_processor] = override_get_docling_processor
    app.dependency_overrides[get_borrower_extractor] = override_get_borrower_extractor

    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client

    app.dependency_overrides.clear()
```
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && python -c "import pytest; from tests.integration.conftest import *; print('All fixtures defined')"`
Expected: "All fixtures defined"
  </verify>
  <done>
- client_with_extraction fixture created
- Uses mock_borrower_extractor_with_data
- Properly wires all dependency overrides
  </done>
</task>

<task type="auto">
  <name>Task 3: Create E2E extraction integration tests</name>
  <files>backend/tests/integration/test_e2e_extraction.py</files>
  <action>
Create a new test file that verifies the complete extraction pipeline.

Create file backend/tests/integration/test_e2e_extraction.py:

```python
"""End-to-end integration tests for document upload to borrower extraction flow.

These tests validate the complete pipeline:
1. Document upload via POST /api/documents/
2. Docling processing (mocked)
3. Borrower extraction (mocked with realistic data)
4. Borrower persistence to database
5. Borrower retrieval via GET /api/borrowers/

Uses mock_borrower_extractor_with_data fixture to avoid real LLM calls
while testing the full integration.
"""

import pytest
from httpx import AsyncClient


@pytest.mark.integration
@pytest.mark.asyncio
async def test_upload_extracts_and_persists_borrower(client_with_extraction: AsyncClient):
    """Test that uploading a document extracts and persists borrowers."""
    # 1. Upload document
    files = {"file": ("loan_app.pdf", b"%PDF-1.4 loan application content", "application/pdf")}
    upload_response = await client_with_extraction.post("/api/documents/", files=files)

    assert upload_response.status_code == 201
    doc_data = upload_response.json()
    doc_id = doc_data["id"]

    # 2. Verify document completed successfully
    status_response = await client_with_extraction.get(f"/api/documents/{doc_id}/status")
    assert status_response.status_code == 200
    assert status_response.json()["status"] == "completed"

    # 3. Verify borrowers were extracted and persisted
    borrowers_response = await client_with_extraction.get("/api/borrowers/")
    assert borrowers_response.status_code == 200
    borrowers_data = borrowers_response.json()

    assert borrowers_data["total"] >= 1
    assert len(borrowers_data["borrowers"]) >= 1

    # 4. Find our extracted borrower
    borrower = next(
        (b for b in borrowers_data["borrowers"] if b["name"] == "John Smith"),
        None,
    )
    assert borrower is not None, "Expected borrower 'John Smith' not found"
    assert borrower["confidence_score"] == 0.85


@pytest.mark.integration
@pytest.mark.asyncio
async def test_extracted_borrower_has_income_records(client_with_extraction: AsyncClient):
    """Test that extracted borrowers have income records persisted."""
    # Upload document to trigger extraction
    files = {"file": ("income_doc.pdf", b"%PDF-1.4 income verification", "application/pdf")}
    upload_response = await client_with_extraction.post("/api/documents/", files=files)
    assert upload_response.status_code == 201

    # Get borrower list
    borrowers_response = await client_with_extraction.get("/api/borrowers/")
    borrowers = borrowers_response.json()["borrowers"]
    borrower = next((b for b in borrowers if b["name"] == "John Smith"), None)
    assert borrower is not None

    # Get borrower detail to see income records
    detail_response = await client_with_extraction.get(f"/api/borrowers/{borrower['id']}")
    assert detail_response.status_code == 200
    detail = detail_response.json()

    # Verify income records
    assert "income_records" in detail
    assert len(detail["income_records"]) == 2

    # Verify income data (sorted by year descending in response)
    years = [inc["year"] for inc in detail["income_records"]]
    assert 2024 in years
    assert 2023 in years

    # Verify income amounts
    income_2024 = next(inc for inc in detail["income_records"] if inc["year"] == 2024)
    assert float(income_2024["amount"]) == 75000.00
    assert income_2024["employer"] == "Acme Corp"


@pytest.mark.integration
@pytest.mark.asyncio
async def test_extracted_borrower_has_source_references(client_with_extraction: AsyncClient):
    """Test that extracted borrowers have source references linking to documents."""
    # Upload document
    files = {"file": ("traced_doc.pdf", b"%PDF-1.4 traced document", "application/pdf")}
    upload_response = await client_with_extraction.post("/api/documents/", files=files)
    assert upload_response.status_code == 201
    doc_id = upload_response.json()["id"]

    # Get borrower detail
    borrowers_response = await client_with_extraction.get("/api/borrowers/")
    borrower = next(
        (b for b in borrowers_response.json()["borrowers"] if b["name"] == "John Smith"),
        None,
    )
    assert borrower is not None

    detail_response = await client_with_extraction.get(f"/api/borrowers/{borrower['id']}")
    detail = detail_response.json()

    # Verify source references
    assert "source_references" in detail
    assert len(detail["source_references"]) >= 1

    # Verify source links to uploaded document
    source = detail["source_references"][0]
    assert source["document_id"] == doc_id
    assert source["page_number"] == 1
    assert "snippet" in source


@pytest.mark.integration
@pytest.mark.asyncio
async def test_search_finds_extracted_borrower(client_with_extraction: AsyncClient):
    """Test that extracted borrowers are searchable."""
    # Upload document
    files = {"file": ("searchable.pdf", b"%PDF-1.4 searchable", "application/pdf")}
    await client_with_extraction.post("/api/documents/", files=files)

    # Search by name
    search_response = await client_with_extraction.get("/api/borrowers/search?name=Smith")
    assert search_response.status_code == 200
    search_data = search_response.json()

    assert search_data["total"] >= 1
    assert any(b["name"] == "John Smith" for b in search_data["borrowers"])


@pytest.mark.integration
@pytest.mark.asyncio
async def test_multiple_documents_extract_borrowers(client_with_extraction: AsyncClient):
    """Test that uploading multiple documents extracts borrowers from each."""
    # Upload 3 documents
    for i in range(3):
        files = {"file": (f"multi_doc_{i}.pdf", f"%PDF-1.4 doc {i}".encode(), "application/pdf")}
        response = await client_with_extraction.post("/api/documents/", files=files)
        assert response.status_code == 201

    # Should have documents listed
    docs_response = await client_with_extraction.get("/api/documents/")
    assert docs_response.status_code == 200
    assert len(docs_response.json()["documents"]) == 3

    # Note: With current mock, each upload creates the same borrower (John Smith)
    # but with different source references. The deduplication happens in the
    # extractor, and since each document creates a fresh extraction, we might
    # get multiple borrowers or one with multiple sources depending on test isolation.
    # This test mainly verifies no errors occur with multiple uploads.
```
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && python -m pytest tests/integration/test_e2e_extraction.py -v --tb=short`
Expected: All tests pass
  </verify>
  <done>
- test_upload_extracts_and_persists_borrower verifies basic flow
- test_extracted_borrower_has_income_records verifies income persistence
- test_extracted_borrower_has_source_references verifies traceability
- test_search_finds_extracted_borrower verifies search works
- test_multiple_documents_extract_borrowers verifies multi-doc handling
  </done>
</task>

</tasks>

<verification>
All verification steps:
1. `pytest tests/integration/test_e2e_extraction.py -v` - all new tests pass
2. `pytest tests/integration/test_e2e_flow.py -v` - existing tests still pass
3. `pytest tests/integration/ -v` - all integration tests pass
</verification>

<success_criteria>
- mock_borrower_extractor_with_data fixture returns realistic test data
- client_with_extraction fixture properly configured
- E2E tests verify upload -> extraction -> persistence -> retrieval
- Tests verify income records and source references are persisted
- Tests verify search finds extracted borrowers
- All integration tests pass (new and existing)
</success_criteria>

<output>
After completion, create `.planning/phases/08-wire-document-to-extraction-pipeline/08-03-SUMMARY.md`
</output>
