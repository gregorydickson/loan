---
phase: 06-gcp-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - infrastructure/terraform/cloud_sql.tf
  - infrastructure/terraform/cloud_storage.tf
  - infrastructure/terraform/cloud_tasks.tf
  - infrastructure/terraform/secrets.tf
autonomous: true

must_haves:
  truths:
    - "Cloud SQL PostgreSQL instance uses private IP via VPC peering"
    - "Cloud Storage bucket has lifecycle policies and uniform access"
    - "Cloud Tasks queue has rate limiting configured"
    - "Secrets are stored in Secret Manager, not Terraform state"
  artifacts:
    - path: "infrastructure/terraform/cloud_sql.tf"
      provides: "PostgreSQL database instance and user"
      contains: "google_sql_database_instance"
    - path: "infrastructure/terraform/cloud_storage.tf"
      provides: "Document storage bucket with lifecycle rules"
      contains: "google_storage_bucket"
    - path: "infrastructure/terraform/cloud_tasks.tf"
      provides: "Async document processing queue"
      contains: "google_cloud_tasks_queue"
    - path: "infrastructure/terraform/secrets.tf"
      provides: "Secret Manager secrets for credentials"
      contains: "google_secret_manager_secret"
  key_links:
    - from: "infrastructure/terraform/cloud_sql.tf"
      to: "infrastructure/terraform/vpc.tf"
      via: "private IP via VPC peering"
      pattern: "depends_on.*private_vpc_connection"
    - from: "infrastructure/terraform/cloud_storage.tf"
      to: "infrastructure/terraform/iam.tf"
      via: "service account storage access"
      pattern: "google_storage_bucket_iam_member"
---

<objective>
Create Terraform configuration for GCP managed services: Cloud SQL PostgreSQL, Cloud Storage, Cloud Tasks, and Secret Manager.

Purpose: These are the stateful data stores and async processing infrastructure that the application depends on. Cloud SQL provides the managed PostgreSQL database, Cloud Storage stores uploaded documents, Cloud Tasks handles async document processing, and Secret Manager secures credentials.

Output: Terraform files that create all managed services with proper configuration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-gcp-infrastructure/06-RESEARCH.md
@.planning/phases/06-gcp-infrastructure/06-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cloud SQL and Secret Manager configuration</name>
  <files>
    infrastructure/terraform/cloud_sql.tf
    infrastructure/terraform/secrets.tf
  </files>
  <action>
**infrastructure/terraform/cloud_sql.tf:**

1. Cloud SQL Instance (google_sql_database_instance):
   - name = "loan-db-${var.environment}"
   - database_version = "POSTGRES_16"
   - region = var.region
   - depends_on = [google_service_networking_connection.private_vpc_connection]
   - deletion_protection = false (for demo; set true for production)

   settings block:
   - tier = "db-f1-micro" (smallest, sufficient for demo)
   - availability_type = "ZONAL"
   - disk_size = 10
   - disk_type = "PD_SSD"

   ip_configuration:
   - ipv4_enabled = false (private IP only)
   - private_network = google_compute_network.private_network.id
   - enable_private_path_for_google_cloud_services = true

   backup_configuration:
   - enabled = true
   - start_time = "03:00"
   - point_in_time_recovery_enabled = true
   - backup_retention_settings { retained_backups = 7 }

2. Database (google_sql_database):
   - name = "loan_extraction"
   - instance = Cloud SQL instance name

3. Database User (google_sql_user):
   - name = "app"
   - instance = Cloud SQL instance name
   - password = var.db_password (from variables)

**infrastructure/terraform/secrets.tf:**

1. Database URL Secret (google_secret_manager_secret + version):
   - secret_id = "database-url"
   - replication { auto {} }
   - Version with connection string:
     postgresql+asyncpg://app:{password}@{private_ip}:5432/loan_extraction
   - Use locals to construct URL from Cloud SQL outputs

2. Gemini API Key Secret (google_secret_manager_secret + version):
   - secret_id = "gemini-api-key"
   - Version with var.gemini_api_key

3. IAM bindings for Cloud Run service account to access secrets:
   - google_secret_manager_secret_iam_member for each secret
   - role = "roles/secretmanager.secretAccessor"
   - member = service account from iam.tf

Note: Secrets are stored in Secret Manager so they're not in Terraform state (which might be in GCS). Cloud Run will reference secrets by name.
  </action>
  <verify>
cd infrastructure/terraform && terraform validate
grep -l "google_sql_database_instance\|google_secret_manager_secret" *.tf
  </verify>
  <done>
cloud_sql.tf creates PostgreSQL 16 instance with private IP, database, and user. secrets.tf creates Secret Manager secrets for database URL and Gemini API key with IAM bindings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Cloud Storage and Cloud Tasks configuration</name>
  <files>
    infrastructure/terraform/cloud_storage.tf
    infrastructure/terraform/cloud_tasks.tf
  </files>
  <action>
**infrastructure/terraform/cloud_storage.tf:**

1. Documents Bucket (google_storage_bucket):
   - name = "${var.project_id}-loan-documents"
   - location = var.region
   - force_destroy = false
   - uniform_bucket_level_access = true
   - public_access_prevention = "enforced"

   versioning { enabled = true }

   lifecycle_rule (transition to NEARLINE after 90 days):
   - condition { age = 90 }
   - action { type = "SetStorageClass", storage_class = "NEARLINE" }

   lifecycle_rule (transition to COLDLINE after 365 days):
   - condition { age = 365 }
   - action { type = "SetStorageClass", storage_class = "COLDLINE" }

   lifecycle_rule (delete old versions):
   - condition { num_newer_versions = 5 }
   - action { type = "Delete" }

2. Bucket IAM (google_storage_bucket_iam_member):
   - bucket = documents bucket name
   - role = "roles/storage.objectAdmin"
   - member = Cloud Run service account

**infrastructure/terraform/cloud_tasks.tf:**

1. Document Processing Queue (google_cloud_tasks_queue):
   - name = "document-processing"
   - location = var.region

   rate_limits:
   - max_dispatches_per_second = 10
   - max_concurrent_dispatches = 5

   retry_config:
   - max_attempts = 5
   - max_retry_duration = "3600s" (1 hour)
   - max_backoff = "3600s"
   - min_backoff = "10s"
   - max_doublings = 5

This provides document storage with cost-optimized lifecycle management and an async processing queue with sensible retry behavior.
  </action>
  <verify>
cd infrastructure/terraform && terraform validate
grep -c "google_storage_bucket\|google_cloud_tasks_queue" cloud_storage.tf cloud_tasks.tf
  </verify>
  <done>
cloud_storage.tf creates bucket with lifecycle policies (NEARLINE at 90d, COLDLINE at 365d) and IAM binding. cloud_tasks.tf creates queue with rate limiting (10/s, 5 concurrent) and retry config.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `terraform validate` passes
2. All 4 new Terraform files exist
3. Cloud SQL uses private IP (ipv4_enabled = false)
4. Secrets reference service account from iam.tf
5. Storage bucket has 3 lifecycle rules
6. Cloud Tasks queue has rate_limits and retry_config
</verification>

<success_criteria>
- [ ] infrastructure/terraform/cloud_sql.tf creates PostgreSQL 16 with private IP and automated backups
- [ ] infrastructure/terraform/secrets.tf creates database-url and gemini-api-key secrets with IAM
- [ ] infrastructure/terraform/cloud_storage.tf creates bucket with lifecycle policies
- [ ] infrastructure/terraform/cloud_tasks.tf creates queue with rate limiting
- [ ] terraform validate passes for all files
- [ ] Cloud SQL depends_on private_vpc_connection from vpc.tf
</success_criteria>

<output>
After completion, create `.planning/phases/06-gcp-infrastructure/06-03-SUMMARY.md`
</output>
