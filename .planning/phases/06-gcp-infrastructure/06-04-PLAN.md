---
phase: 06-gcp-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - infrastructure/terraform/cloud_run.tf
  - infrastructure/terraform/outputs.tf
  - infrastructure/terraform/terraform.tfvars.example
autonomous: false

must_haves:
  truths:
    - "Backend Cloud Run service connects to Cloud SQL via private IP"
    - "Frontend Cloud Run service has backend API URL configured"
    - "Cloud Run services use direct VPC egress (no VPC connector cost)"
    - "terraform output shows backend_url and frontend_url"
  artifacts:
    - path: "infrastructure/terraform/cloud_run.tf"
      provides: "Backend and frontend Cloud Run services"
      contains: "google_cloud_run_v2_service"
    - path: "infrastructure/terraform/outputs.tf"
      provides: "Service URLs and connection strings"
      contains: "output"
    - path: "infrastructure/terraform/terraform.tfvars.example"
      provides: "Example variable values for users"
      contains: "project_id"
  key_links:
    - from: "infrastructure/terraform/cloud_run.tf"
      to: "infrastructure/terraform/secrets.tf"
      via: "secret references in env vars"
      pattern: "secret_key_ref"
    - from: "infrastructure/terraform/cloud_run.tf"
      to: "infrastructure/terraform/vpc.tf"
      via: "direct VPC egress"
      pattern: "vpc_access.*network_interfaces"
---

<objective>
Create Cloud Run service configurations for backend and frontend, plus Terraform outputs for service URLs.

Purpose: Cloud Run provides serverless container hosting with automatic scaling. Backend connects to Cloud SQL via VPC for security. Frontend is configured with backend API URL. Outputs provide the deployed URLs.

Output: Complete Terraform configuration that deploys the full application stack
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-gcp-infrastructure/06-RESEARCH.md
@.planning/phases/06-gcp-infrastructure/06-01-SUMMARY.md
@.planning/phases/06-gcp-infrastructure/06-02-SUMMARY.md
@.planning/phases/06-gcp-infrastructure/06-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cloud Run service configurations</name>
  <files>infrastructure/terraform/cloud_run.tf</files>
  <action>
**infrastructure/terraform/cloud_run.tf:**

Use google_cloud_run_v2_service (not v1) for better features and direct VPC egress.

**Backend Service:**
```hcl
resource "google_cloud_run_v2_service" "backend" {
  name     = "loan-backend-${var.environment}"
  location = var.region
  ingress  = "INGRESS_TRAFFIC_ALL"

  template {
    service_account = google_service_account.cloud_run_sa.email

    containers {
      image = "${var.region}-docker.pkg.dev/${var.project_id}/loan-repo/backend:${var.image_tag}"

      resources {
        limits = {
          cpu    = "1"
          memory = "1Gi"  # Docling needs memory
        }
        cpu_idle = true  # Scale to zero
      }

      # Database URL from Secret Manager
      env {
        name = "DATABASE_URL"
        value_source {
          secret_key_ref {
            secret  = google_secret_manager_secret.database_url.secret_id
            version = "latest"
          }
        }
      }

      # Gemini API key from Secret Manager
      env {
        name = "GEMINI_API_KEY"
        value_source {
          secret_key_ref {
            secret  = google_secret_manager_secret.gemini_api_key.secret_id
            version = "latest"
          }
        }
      }

      # GCS bucket name
      env {
        name  = "GCS_BUCKET"
        value = google_storage_bucket.documents.name
      }

      # Cloud Tasks queue path
      env {
        name  = "CLOUD_TASKS_QUEUE"
        value = google_cloud_tasks_queue.document_processing.id
      }

      ports {
        container_port = 8080
      }

      startup_probe {
        http_get {
          path = "/health"
        }
        initial_delay_seconds = 10
        timeout_seconds       = 5
        period_seconds        = 10
        failure_threshold     = 3
      }
    }

    # Direct VPC egress for Cloud SQL access
    vpc_access {
      network_interfaces {
        network    = google_compute_network.private_network.id
        subnetwork = google_compute_subnetwork.cloud_run_subnet.id
      }
      egress = "PRIVATE_RANGES_ONLY"
    }

    scaling {
      min_instance_count = 0
      max_instance_count = 10
    }
  }

  depends_on = [
    google_secret_manager_secret_version.database_url,
    google_secret_manager_secret_version.gemini_api_key,
  ]
}
```

**Frontend Service:**
```hcl
resource "google_cloud_run_v2_service" "frontend" {
  name     = "loan-frontend-${var.environment}"
  location = var.region
  ingress  = "INGRESS_TRAFFIC_ALL"

  template {
    containers {
      image = "${var.region}-docker.pkg.dev/${var.project_id}/loan-repo/frontend:${var.image_tag}"

      resources {
        limits = {
          cpu    = "1"
          memory = "512Mi"
        }
        cpu_idle = true
      }

      # Backend API URL for frontend to call
      env {
        name  = "NEXT_PUBLIC_API_URL"
        value = google_cloud_run_v2_service.backend.uri
      }

      ports {
        container_port = 8080
      }
    }

    scaling {
      min_instance_count = 0
      max_instance_count = 5
    }
  }

  depends_on = [google_cloud_run_v2_service.backend]
}
```

**IAM for public access (allow unauthenticated):**
```hcl
resource "google_cloud_run_v2_service_iam_member" "backend_public" {
  name     = google_cloud_run_v2_service.backend.name
  location = var.region
  role     = "roles/run.invoker"
  member   = "allUsers"
}

resource "google_cloud_run_v2_service_iam_member" "frontend_public" {
  name     = google_cloud_run_v2_service.frontend.name
  location = var.region
  role     = "roles/run.invoker"
  member   = "allUsers"
}
```

Note: Backend needs VPC access for Cloud SQL, frontend doesn't. Frontend references backend URL for API calls.
  </action>
  <verify>
cd infrastructure/terraform && terraform validate
grep -c "google_cloud_run_v2_service" cloud_run.tf
  </verify>
  <done>
cloud_run.tf creates backend service with VPC egress, secrets, and probes; frontend service with backend URL; and IAM bindings for public access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create outputs and example tfvars</name>
  <files>
    infrastructure/terraform/outputs.tf
    infrastructure/terraform/terraform.tfvars.example
  </files>
  <action>
**infrastructure/terraform/outputs.tf:**

```hcl
output "backend_url" {
  description = "Backend Cloud Run service URL"
  value       = google_cloud_run_v2_service.backend.uri
}

output "frontend_url" {
  description = "Frontend Cloud Run service URL"
  value       = google_cloud_run_v2_service.frontend.uri
}

output "database_instance" {
  description = "Cloud SQL instance name"
  value       = google_sql_database_instance.main.name
}

output "database_connection_name" {
  description = "Cloud SQL connection name for proxy"
  value       = google_sql_database_instance.main.connection_name
}

output "database_private_ip" {
  description = "Cloud SQL private IP address"
  value       = google_sql_database_instance.main.private_ip_address
}

output "storage_bucket" {
  description = "GCS bucket for document storage"
  value       = google_storage_bucket.documents.name
}

output "cloud_tasks_queue" {
  description = "Cloud Tasks queue path"
  value       = google_cloud_tasks_queue.document_processing.id
}
```

**infrastructure/terraform/terraform.tfvars.example:**

```hcl
# Copy this file to terraform.tfvars and fill in values
# Or set TF_VAR_* environment variables

# Required
project_id = "your-gcp-project-id"

# Sensitive - prefer TF_VAR_db_password environment variable
# db_password = "your-secure-database-password"

# Sensitive - prefer TF_VAR_gemini_api_key environment variable
# gemini_api_key = "your-gemini-api-key"

# Optional (defaults shown)
# region      = "us-central1"
# environment = "prod"
# image_tag   = "latest"
```

Add a note to .gitignore to exclude terraform.tfvars (secrets).
  </action>
  <verify>
cd infrastructure/terraform && terraform validate
grep -c "output" outputs.tf
cat terraform.tfvars.example
  </verify>
  <done>
outputs.tf provides 7 outputs (URLs, database info, bucket, queue). terraform.tfvars.example shows required variables with comments about sensitive values.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Terraform configuration for GCP infrastructure:
- VPC with private services access
- Cloud SQL PostgreSQL 16 with private IP
- Cloud Storage bucket with lifecycle policies
- Cloud Tasks queue with rate limiting
- Secret Manager for credentials
- Cloud Run services for backend and frontend
- IAM with least-privilege roles
- Deployment scripts (setup-gcp.sh, deploy.sh)
- Dockerfiles for both services
  </what-built>
  <how-to-verify>
1. Review the Terraform configuration:
   ```bash
   cd infrastructure/terraform
   terraform init -backend=false
   terraform validate
   terraform fmt -check
   ```

2. Review the plan output:
   ```bash
   # Set required variables for plan (use dummy values)
   export TF_VAR_project_id="test-project"
   export TF_VAR_db_password="test-password"
   export TF_VAR_gemini_api_key="test-key"
   terraform plan
   ```

3. Test Docker builds locally:
   ```bash
   docker build -t loan-backend ./backend
   docker build -t loan-frontend ./frontend
   ```

4. Verify all required files exist:
   ```bash
   ls infrastructure/terraform/*.tf
   ls infrastructure/scripts/*.sh
   ls backend/Dockerfile frontend/Dockerfile
   ```

Expected: All commands succeed, terraform plan shows expected resources
  </how-to-verify>
  <resume-signal>Type "approved" to confirm infrastructure configuration is correct, or describe any issues that need fixing</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `terraform init -backend=false && terraform validate` passes
2. `terraform fmt -check` passes
3. All .tf files exist: main.tf, variables.tf, vpc.tf, iam.tf, cloud_sql.tf, cloud_storage.tf, cloud_tasks.tf, secrets.tf, cloud_run.tf, outputs.tf
4. Both Dockerfiles build successfully
5. Both deployment scripts pass syntax check
</verification>

<success_criteria>
- [ ] cloud_run.tf creates backend service with VPC egress, secrets, and health probe
- [ ] cloud_run.tf creates frontend service with backend API URL
- [ ] cloud_run.tf adds IAM bindings for public access (allUsers invoker)
- [ ] outputs.tf provides backend_url, frontend_url, database info, bucket, queue
- [ ] terraform.tfvars.example shows all required variables
- [ ] Full terraform validate passes
- [ ] User approves configuration via checkpoint
</success_criteria>

<output>
After completion, create `.planning/phases/06-gcp-infrastructure/06-04-SUMMARY.md`
</output>
