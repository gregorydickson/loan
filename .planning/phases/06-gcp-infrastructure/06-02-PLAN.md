---
phase: 06-gcp-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Dockerfile
  - frontend/Dockerfile
  - frontend/next.config.ts
  - infrastructure/scripts/setup-gcp.sh
  - infrastructure/scripts/deploy.sh
autonomous: true

must_haves:
  truths:
    - "Backend Docker image builds successfully"
    - "Frontend Docker image builds successfully with standalone output"
    - "Setup script enables required GCP APIs"
    - "Deploy script builds images and runs terraform apply"
  artifacts:
    - path: "backend/Dockerfile"
      provides: "Multi-stage FastAPI container build"
      contains: "FROM python"
    - path: "frontend/Dockerfile"
      provides: "Multi-stage Next.js standalone build"
      contains: "FROM node"
    - path: "infrastructure/scripts/setup-gcp.sh"
      provides: "GCP project initialization"
      contains: "gcloud services enable"
    - path: "infrastructure/scripts/deploy.sh"
      provides: "Automated deployment script"
      contains: "docker build"
  key_links:
    - from: "frontend/next.config.ts"
      to: "frontend/Dockerfile"
      via: "standalone output mode"
      pattern: "output.*standalone"
    - from: "infrastructure/scripts/deploy.sh"
      to: "backend/Dockerfile"
      via: "docker build command"
      pattern: "docker build.*backend"
---

<objective>
Create production Dockerfiles for backend and frontend, plus deployment automation scripts for GCP setup and deployment.

Purpose: Multi-stage Dockerfiles minimize image size for faster Cloud Run cold starts. Deployment scripts automate the tedious manual steps of GCP setup and application deployment.

Output: Working Dockerfiles that build locally, and executable shell scripts for GCP operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-gcp-infrastructure/06-RESEARCH.md
@backend/pyproject.toml
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend and frontend Dockerfiles</name>
  <files>
    backend/Dockerfile
    frontend/Dockerfile
    frontend/next.config.ts
  </files>
  <action>
**backend/Dockerfile** - Multi-stage FastAPI build:

Stage 1 (builder):
- FROM python:3.12-slim AS builder
- WORKDIR /build
- Install build dependencies: gcc, libpq-dev (for asyncpg)
- Copy pyproject.toml
- pip install --prefix=/install --no-cache-dir . (installs to /install)

Stage 2 (runtime):
- FROM python:3.12-slim AS runtime
- WORKDIR /app
- Install runtime deps only: libpq5 (asyncpg runtime lib)
- Create non-root user: useradd --create-home --shell /bin/bash app
- COPY --from=builder /install /usr/local
- COPY src/ ./src/
- COPY alembic/ ./alembic/
- COPY alembic.ini ./
- RUN python -m compileall -q ./src/ (pre-compile for faster startup)
- USER app
- ENV PORT=8080
- CMD ["python", "-m", "uvicorn", "src.api.main:app", "--host", "0.0.0.0", "--port", "8080"]

**frontend/Dockerfile** - Multi-stage Next.js standalone build:

Stage 1 (deps):
- FROM node:20-alpine AS deps
- WORKDIR /app
- COPY package.json package-lock.json* ./
- RUN npm ci

Stage 2 (builder):
- FROM node:20-alpine AS builder
- WORKDIR /app
- COPY --from=deps /app/node_modules ./node_modules
- COPY . .
- ENV NEXT_TELEMETRY_DISABLED=1
- RUN npm run build

Stage 3 (runtime):
- FROM node:20-alpine AS runtime
- WORKDIR /app
- ENV NODE_ENV=production NEXT_TELEMETRY_DISABLED=1
- Create non-root user: addgroup --system nodejs && adduser --system nextjs
- COPY --from=builder /app/.next/standalone ./
- COPY --from=builder /app/.next/static ./.next/static
- COPY --from=builder /app/public ./public
- USER nextjs
- ENV PORT=8080 HOSTNAME="0.0.0.0"
- CMD ["node", "server.js"]

**frontend/next.config.ts** - Enable standalone output:
```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: "standalone",
};

export default nextConfig;
```

This enables Next.js standalone output mode required for the optimized Docker build.
  </action>
  <verify>
# Test backend Dockerfile builds
cd /Users/gregorydickson/stackpoint/loan/backend && docker build -t loan-backend-test . --no-cache

# Test frontend Dockerfile builds (after next.config.ts update)
cd /Users/gregorydickson/stackpoint/loan/frontend && docker build -t loan-frontend-test . --no-cache
  </verify>
  <done>
Both Dockerfiles build successfully. Backend uses python:3.12-slim multi-stage. Frontend uses node:20-alpine multi-stage with standalone output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GCP setup and deployment scripts</name>
  <files>
    infrastructure/scripts/setup-gcp.sh
    infrastructure/scripts/deploy.sh
  </files>
  <action>
Create the infrastructure/scripts directory.

**infrastructure/scripts/setup-gcp.sh:**
```bash
#!/bin/bash
# GCP project initialization script
set -euo pipefail

PROJECT_ID="${1:?Usage: setup-gcp.sh PROJECT_ID [REGION]}"
REGION="${2:-us-central1}"

echo "Setting up GCP project: $PROJECT_ID in region: $REGION"

# Set project
gcloud config set project "$PROJECT_ID"

# Enable required APIs
echo "Enabling required APIs..."
gcloud services enable \
    run.googleapis.com \
    sqladmin.googleapis.com \
    secretmanager.googleapis.com \
    cloudtasks.googleapis.com \
    servicenetworking.googleapis.com \
    artifactregistry.googleapis.com \
    cloudbuild.googleapis.com \
    compute.googleapis.com

# Create Artifact Registry repository
echo "Creating Artifact Registry repository..."
gcloud artifacts repositories create loan-repo \
    --repository-format=docker \
    --location="$REGION" \
    --description="Loan extraction Docker images" \
    2>/dev/null || echo "Repository already exists"

# Configure Docker authentication
echo "Configuring Docker authentication..."
gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet

# Create Terraform state bucket
STATE_BUCKET="${PROJECT_ID}-terraform-state"
echo "Creating Terraform state bucket: $STATE_BUCKET"
gsutil mb -l "$REGION" "gs://${STATE_BUCKET}" 2>/dev/null || echo "Bucket already exists"
gsutil versioning set on "gs://${STATE_BUCKET}"

echo ""
echo "Setup complete!"
echo ""
echo "Next steps:"
echo "1. cd infrastructure/terraform && terraform init"
echo "2. Set TF_VAR_project_id, TF_VAR_db_password, TF_VAR_gemini_api_key environment variables"
echo "3. Run: terraform plan"
echo "4. Run: terraform apply"
```

**infrastructure/scripts/deploy.sh:**
```bash
#!/bin/bash
# Automated deployment script
set -euo pipefail

PROJECT_ID="${PROJECT_ID:?Set PROJECT_ID environment variable}"
REGION="${REGION:-us-central1}"
TAG="${TAG:-$(git rev-parse --short HEAD 2>/dev/null || echo 'latest')}"

REGISTRY="${REGION}-docker.pkg.dev/${PROJECT_ID}/loan-repo"

echo "=========================================="
echo "Deploying Loan Extraction System"
echo "Project: $PROJECT_ID"
echo "Region: $REGION"
echo "Tag: $TAG"
echo "=========================================="

# Build and push backend
echo ""
echo "[1/4] Building backend..."
docker build -t "${REGISTRY}/backend:${TAG}" -t "${REGISTRY}/backend:latest" ./backend
echo "[2/4] Pushing backend..."
docker push "${REGISTRY}/backend:${TAG}"
docker push "${REGISTRY}/backend:latest"

# Build and push frontend
echo ""
echo "[3/4] Building frontend..."
docker build -t "${REGISTRY}/frontend:${TAG}" -t "${REGISTRY}/frontend:latest" ./frontend
echo "Pushing frontend..."
docker push "${REGISTRY}/frontend:${TAG}"
docker push "${REGISTRY}/frontend:latest"

# Apply Terraform
echo ""
echo "[4/4] Applying Terraform..."
cd infrastructure/terraform
terraform apply -auto-approve -var="image_tag=${TAG}"

# Get service URLs
BACKEND_URL=$(terraform output -raw backend_url 2>/dev/null || echo "not yet deployed")
FRONTEND_URL=$(terraform output -raw frontend_url 2>/dev/null || echo "not yet deployed")

echo ""
echo "=========================================="
echo "Deployment complete!"
echo "=========================================="
echo "Backend URL: $BACKEND_URL"
echo "Frontend URL: $FRONTEND_URL"
echo ""
echo "Health check: curl ${BACKEND_URL}/health"
```

Make both scripts executable: chmod +x infrastructure/scripts/*.sh
  </action>
  <verify>
# Verify scripts are executable and have correct shebang
ls -la infrastructure/scripts/
head -1 infrastructure/scripts/setup-gcp.sh
head -1 infrastructure/scripts/deploy.sh

# Verify script syntax (bash -n does syntax check without executing)
bash -n infrastructure/scripts/setup-gcp.sh
bash -n infrastructure/scripts/deploy.sh
  </verify>
  <done>
Both scripts created and executable. setup-gcp.sh enables 8 GCP APIs and creates Artifact Registry + state bucket. deploy.sh builds images and runs terraform apply.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `docker build -t test-backend ./backend` succeeds
2. `docker build -t test-frontend ./frontend` succeeds
3. `bash -n infrastructure/scripts/setup-gcp.sh` passes syntax check
4. `bash -n infrastructure/scripts/deploy.sh` passes syntax check
5. frontend/next.config.ts contains `output: "standalone"`
</verification>

<success_criteria>
- [ ] backend/Dockerfile exists with multi-stage build (builder + runtime stages)
- [ ] frontend/Dockerfile exists with multi-stage build (deps + builder + runtime stages)
- [ ] frontend/next.config.ts has output: "standalone" configured
- [ ] infrastructure/scripts/setup-gcp.sh is executable and enables required APIs
- [ ] infrastructure/scripts/deploy.sh is executable and builds/pushes images
- [ ] Both Docker images build successfully locally
</success_criteria>

<output>
After completion, create `.planning/phases/06-gcp-infrastructure/06-02-SUMMARY.md`
</output>
