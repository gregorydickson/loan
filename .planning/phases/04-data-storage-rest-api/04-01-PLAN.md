---
phase: 04-data-storage-rest-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/storage/repositories.py
  - backend/tests/unit/test_borrower_repository.py
autonomous: true

must_haves:
  truths:
    - "BorrowerRepository creates borrowers with related income, accounts, and sources"
    - "BorrowerRepository retrieves borrowers by ID with all relationships eagerly loaded (no lazy loading errors)"
    - "BorrowerRepository searches borrowers by name (case-insensitive)"
    - "BorrowerRepository searches borrowers by account number"
    - "BorrowerRepository lists borrowers with pagination"
  artifacts:
    - path: "backend/src/storage/repositories.py"
      provides: "BorrowerRepository class with CRUD and search"
      contains: "class BorrowerRepository"
    - path: "backend/tests/unit/test_borrower_repository.py"
      provides: "Unit tests for BorrowerRepository"
      min_lines: 150
  key_links:
    - from: "backend/src/storage/repositories.py"
      to: "backend/src/storage/models.py"
      via: "imports Borrower, IncomeRecord, AccountNumber, SourceReference"
      pattern: "from src\\.storage\\.models import.*Borrower"
---

<objective>
Create BorrowerRepository with full CRUD operations and search functionality

Purpose: Provide data access layer for borrower persistence, enabling the API to store and retrieve extracted borrower data with relationships (income records, account numbers, source references).

Output: BorrowerRepository class in repositories.py with unit tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-data-storage-rest-api/04-RESEARCH.md

# Existing patterns to follow
@backend/src/storage/repositories.py
@backend/src/storage/models.py
@backend/src/storage/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BorrowerRepository to repositories.py</name>
  <files>backend/src/storage/repositories.py</files>
  <action>
Add BorrowerRepository class to the existing repositories.py file. Follow the DocumentRepository pattern already in the file.

**Methods to implement:**

1. `__init__(self, session: AsyncSession)` - Store session

2. `create(self, borrower: Borrower, income_records: list[IncomeRecord], account_numbers: list[AccountNumber], source_references: list[SourceReference]) -> Borrower`:
   - Add borrower, flush to get ID
   - Set borrower_id on all related entities and add them
   - Flush and refresh borrower
   - Return borrower

3. `get_by_id(self, borrower_id: UUID) -> Borrower | None`:
   - Use `selectinload()` for all three relationships
   - Chain `selectinload(SourceReference.document)` for nested document data
   - Return scalar_one_or_none()

4. `search_by_name(self, name: str, limit: int = 100, offset: int = 0) -> Sequence[Borrower]`:
   - Use `ilike(f"%{name}%")` for case-insensitive partial match
   - Use `selectinload()` for income_records only (list view doesn't need all relations)
   - Order by name, apply offset/limit

5. `search_by_account(self, account_number: str, limit: int = 100, offset: int = 0) -> Sequence[Borrower]`:
   - Join with AccountNumber
   - Use `ilike(f"%{account_number}%")` on AccountNumber.number
   - Use `unique().scalars().all()` after join (prevents duplicates)
   - Load income_records and account_numbers with selectinload

6. `list_borrowers(self, limit: int = 100, offset: int = 0) -> Sequence[Borrower]`:
   - Order by created_at descending
   - Load income_records with selectinload
   - Apply offset/limit

7. `count(self) -> int`:
   - Use `select(func.count()).select_from(Borrower)`
   - Return scalar result

**Required imports to add:**
- `from sqlalchemy import func`
- `from sqlalchemy.orm import selectinload`
- `from src.storage.models import Borrower, IncomeRecord, AccountNumber, SourceReference`
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.storage.repositories import BorrowerRepository; print('BorrowerRepository imported successfully')"`
  </verify>
  <done>BorrowerRepository class exists with all 7 methods, imports compile without error</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for BorrowerRepository</name>
  <files>backend/tests/unit/test_borrower_repository.py</files>
  <action>
Create comprehensive unit tests for BorrowerRepository. Follow the existing test patterns in the codebase.

**Test fixtures needed:**
- `sample_borrower()` - Creates Borrower model with test data
- `sample_income_record()` - Creates IncomeRecord model
- `sample_account_number()` - Creates AccountNumber model
- `sample_source_reference(document_id: UUID)` - Creates SourceReference (needs document FK)

**Test cases to implement:**

1. `test_create_borrower_with_relations`:
   - Create borrower with income, accounts, sources
   - Assert all IDs generated
   - Assert relationships accessible
   - **CRITICAL:** Assert that all related entities have correct `borrower_id` foreign key set:
     - `assert income_record.borrower_id == created_borrower.id`
     - `assert account_number.borrower_id == created_borrower.id`
     - `assert source_reference.borrower_id == created_borrower.id`

2. `test_get_by_id_returns_borrower_with_relations`:
   - Create borrower, fetch by ID
   - Assert all relationships loaded (not lazy-loading error)
   - Access `borrower.income_records`, `borrower.account_numbers`, `borrower.source_references` without error

3. `test_get_by_id_returns_none_for_missing`:
   - Query random UUID, assert None

4. `test_search_by_name_case_insensitive`:
   - Create "John Smith" borrower
   - Search "john", "SMITH", "john smith"
   - All should return the borrower

5. `test_search_by_name_partial_match`:
   - Create "Johnson" borrower
   - Search "john" should find it

6. `test_search_by_account_number`:
   - Create borrower with account "ACC-12345"
   - Search "12345" should find it

7. `test_list_borrowers_pagination`:
   - Create 5 borrowers
   - List with limit=2, offset=0 returns first 2
   - List with limit=2, offset=2 returns next 2

8. `test_count_returns_total`:
   - Create 3 borrowers
   - Count returns 3

**Use pytest-asyncio and async fixtures. Use in-memory SQLite with aiosqlite for isolation.**
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && python -m pytest tests/unit/test_borrower_repository.py -v --tb=short`
  </verify>
  <done>All 8 test cases pass, tests cover create, get, search, list, and count operations with borrower_id FK verification</done>
</task>

</tasks>

<verification>
1. BorrowerRepository can be imported: `python -c "from src.storage.repositories import BorrowerRepository"`
2. All tests pass: `pytest tests/unit/test_borrower_repository.py -v`
3. Type check passes: `mypy src/storage/repositories.py --ignore-missing-imports`
</verification>

<success_criteria>
- BorrowerRepository class with create, get_by_id, search_by_name, search_by_account, list_borrowers, count methods
- All methods use `selectinload()` for eager loading relationships (no lazy loading errors)
- search_by_name is case-insensitive with partial matching
- search_by_account joins through AccountNumber table
- 8 unit tests covering all methods
- Test for create verifies borrower_id FK is set on all related entities
- All tests pass with pytest
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-storage-rest-api/04-01-SUMMARY.md`
</output>
