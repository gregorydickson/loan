---
phase: 01-foundation-data-models
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/models/borrower.py
  - backend/src/models/document.py
  - backend/src/models/__init__.py
  - backend/tests/unit/__init__.py
  - backend/tests/unit/test_models.py
autonomous: true

must_haves:
  truths:
    - "BorrowerRecord Pydantic model validates sample borrower JSON with all required fields"
    - "All Pydantic models serialize to JSON and deserialize back correctly (round-trip)"
    - "Address model validates zip code format (5-digit or 5+4)"
    - "IncomeRecord model validates positive amounts and allowed period values"
    - "SourceReference model tracks document_id, page_number, and text snippet"
    - "Confidence score validated to be between 0.0 and 1.0"
  artifacts:
    - path: "backend/src/models/borrower.py"
      provides: "BorrowerRecord, Address, IncomeRecord models"
      contains: "class BorrowerRecord"
    - path: "backend/src/models/document.py"
      provides: "SourceReference, DocumentMetadata models"
      contains: "class SourceReference"
    - path: "backend/tests/unit/test_models.py"
      provides: "Unit tests for Pydantic models"
      min_lines: 50
  key_links:
    - from: "backend/src/models/borrower.py"
      to: "backend/src/models/document.py"
      via: "SourceReference import"
      pattern: "from.*document.*import.*SourceReference"
    - from: "backend/src/models/__init__.py"
      to: "backend/src/models/borrower.py"
      via: "re-export"
      pattern: "from.*borrower.*import"
---

<objective>
Create the Pydantic data models that represent extracted borrower information from loan documents, with full validation and JSON serialization.

Purpose: These models are the contract for all extraction output. They define exactly what data the LLM extraction engine must produce and what the API/frontend will consume. Proper validation prevents bad data from propagating through the system.

Output: Complete Pydantic v2 models for BorrowerRecord, Address, IncomeRecord, SourceReference with unit tests proving serialization works.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-models/01-RESEARCH.md
@.planning/phases/01-foundation-data-models/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SourceReference and DocumentMetadata models</name>
  <files>
    backend/src/models/document.py
  </files>
  <action>
Create the document-related Pydantic models for source attribution.

Create `backend/src/models/document.py` with:

1. **SourceReference** model for tracking where extracted data came from:
   - document_id: UUID (required, identifies the source document)
   - document_name: str (required, human-readable filename)
   - page_number: int (required, Field with ge=1)
   - section: str | None (optional, e.g., "Income Verification", "Personal Information")
   - snippet: str (required, Field with max_length=500, the text that was extracted from)
   - model_config with from_attributes=True for ORM compatibility

2. **DocumentMetadata** model for document tracking (used in later phases):
   - id: UUID (default_factory=uuid4)
   - filename: str (required, min_length=1)
   - file_hash: str (required, SHA-256 hash for deduplication)
   - file_type: Literal["pdf", "docx", "png", "jpg", "jpeg"]
   - file_size_bytes: int (Field with ge=0)
   - storage_uri: str | None (GCS URI, None until uploaded)
   - status: Literal["pending", "processing", "completed", "failed"]
   - error_message: str | None
   - created_at: datetime (default_factory=lambda: datetime.now(timezone.utc))
   - updated_at: datetime (default_factory=lambda: datetime.now(timezone.utc))
   - model_config with from_attributes=True

Use Pydantic v2 patterns:
- Use `from typing import Literal` for constrained strings
- Use `datetime.now(timezone.utc)` not deprecated `datetime.utcnow()`
- Use Field() for all constraints and descriptions
- Use `str | None` not `Optional[str]`
  </action>
  <verify>
cd backend && python -c "from src.models.document import SourceReference, DocumentMetadata; print('Document models import OK')"
  </verify>
  <done>
SourceReference and DocumentMetadata models defined with proper validation. Both models can be imported without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create borrower data models</name>
  <files>
    backend/src/models/borrower.py
    backend/src/models/__init__.py
  </files>
  <action>
Create the core borrower data models following RESEARCH.md patterns exactly.

Create `backend/src/models/borrower.py` with:

1. **Address** model:
   - street: str (Field with min_length=1, description="Street address line")
   - city: str (Field with min_length=1)
   - state: str (Field with min_length=2, max_length=2, description="Two-letter state code")
   - zip_code: str (Field with pattern=r"^\d{5}(-\d{4})?$" for 5-digit or 5+4 format)
   - country: str (Field with default="USA")

2. **IncomeRecord** model:
   - amount: Decimal (Field with gt=0, description="Income amount in USD")
   - period: str (Field, description="Income period: annual, monthly, weekly, biweekly")
   - year: int (Field with ge=1900, le=2100)
   - source_type: str (description="Employment, self-employment, other")
   - employer: str | None (default=None)
   - @field_validator("period") that validates against allowed values {"annual", "monthly", "weekly", "biweekly"} and lowercases

3. **BorrowerRecord** model (the main extraction output):
   - id: UUID (default_factory=uuid4)
   - name: str (Field with min_length=1)
   - ssn: str | None (Field with default=None, pattern for XXX-XX-XXXX format, description noting this is sensitive)
   - phone: str | None (Field with default=None, description for contact)
   - email: str | None (Field with default=None)
   - address: Address | None (default=None)
   - income_history: list[IncomeRecord] (default_factory=list)
   - account_numbers: list[str] (default_factory=list)
   - loan_numbers: list[str] (default_factory=list)
   - sources: list[SourceReference] (default_factory=list) - import from document.py
   - confidence_score: float (Field with ge=0.0, le=1.0)
   - extracted_at: datetime (default_factory=lambda: datetime.now(timezone.utc))
   - model_config with from_attributes=True

Update `backend/src/models/__init__.py` to re-export all models:
```python
from src.models.borrower import Address, BorrowerRecord, IncomeRecord
from src.models.document import DocumentMetadata, SourceReference

__all__ = [
    "Address",
    "BorrowerRecord",
    "DocumentMetadata",
    "IncomeRecord",
    "SourceReference",
]
```

AVOID: Using deprecated .dict() or .json() methods (use model_dump, model_dump_json). Using datetime.utcnow(). Using Optional[X] instead of X | None.
  </action>
  <verify>
cd backend && python -c "from src.models import BorrowerRecord, Address, IncomeRecord, SourceReference, DocumentMetadata; print('All models import OK')"
  </verify>
  <done>
All borrower models defined with nested structures. Models re-exported from __init__.py. Import from src.models works.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for model validation and serialization</name>
  <files>
    backend/tests/unit/__init__.py
    backend/tests/unit/test_models.py
  </files>
  <action>
Create comprehensive unit tests proving models work correctly.

Create `backend/tests/unit/__init__.py` (empty file).

Create `backend/tests/unit/test_models.py` with tests:

1. **test_address_validation**:
   - Valid address with all fields passes
   - Invalid state code (3 chars) raises ValidationError
   - Invalid zip code (4 digits) raises ValidationError
   - Valid 5+4 zip code (12345-6789) passes

2. **test_income_record_validation**:
   - Valid income record passes
   - Zero or negative amount raises ValidationError
   - Invalid period value raises ValidationError
   - Period is lowercased automatically (test "ANNUAL" -> "annual")

3. **test_source_reference_validation**:
   - Valid source reference passes
   - Page number 0 raises ValidationError (must be >= 1)
   - Snippet over 500 chars raises ValidationError

4. **test_borrower_record_complete**:
   - Create full BorrowerRecord with all nested objects
   - Verify all fields accessible
   - Verify sources list contains SourceReference objects

5. **test_borrower_record_minimal**:
   - Create BorrowerRecord with only required fields (name, confidence_score)
   - Verify defaults work (empty lists, None for optional fields)

6. **test_model_json_roundtrip**:
   - Create full BorrowerRecord
   - Serialize to JSON string with model_dump_json()
   - Deserialize back with model_validate_json()
   - Assert all fields match original

7. **test_model_dict_serialization**:
   - Create BorrowerRecord
   - Call model_dump(mode='json') for JSON-compatible dict
   - Verify datetime serialized to ISO string
   - Verify UUID serialized to string
   - Verify Decimal serialized properly

8. **test_confidence_score_bounds**:
   - confidence_score=0.0 passes
   - confidence_score=1.0 passes
   - confidence_score=-0.1 raises ValidationError
   - confidence_score=1.1 raises ValidationError

9. **test_document_metadata_status**:
   - Valid status values ("pending", "completed") pass
   - Invalid status ("unknown") raises ValidationError

Use pytest patterns:
- Import ValidationError from pydantic
- Use pytest.raises(ValidationError) for error cases
- Use descriptive test names
  </action>
  <verify>
cd backend && python -m pytest tests/unit/test_models.py -v
  </verify>
  <done>
All model tests pass. JSON round-trip verified. Validation constraints confirmed working.
  </done>
</task>

</tasks>

<verification>
Run the following to verify Phase 01-03 completion:

```bash
# 1. All models import successfully
cd backend && python -c "from src.models import BorrowerRecord, Address, IncomeRecord, SourceReference, DocumentMetadata"

# 2. All tests pass
cd backend && python -m pytest tests/unit/test_models.py -v

# 3. Verify JSON serialization works
cd backend && python -c "
from src.models import BorrowerRecord, Address, IncomeRecord, SourceReference
from uuid import uuid4
from decimal import Decimal

# Create full borrower
borrower = BorrowerRecord(
    name='John Doe',
    address=Address(street='123 Main St', city='Austin', state='TX', zip_code='78701'),
    income_history=[IncomeRecord(amount=Decimal('75000'), period='annual', year=2024, source_type='employment', employer='Acme Corp')],
    sources=[SourceReference(document_id=uuid4(), document_name='loan_app.pdf', page_number=1, snippet='John Doe, 123 Main St')],
    confidence_score=0.85
)

# Round-trip test
json_str = borrower.model_dump_json()
restored = BorrowerRecord.model_validate_json(json_str)
assert restored.name == borrower.name
assert restored.confidence_score == borrower.confidence_score
print('JSON round-trip: OK')
"
```
</verification>

<success_criteria>
1. All models import from `src.models` without errors
2. `pytest tests/unit/test_models.py` shows all tests passing
3. BorrowerRecord validates sample borrower JSON with all fields
4. JSON serialization round-trip preserves all data
5. Validation constraints work (invalid data raises ValidationError)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-models/01-03-SUMMARY.md`
</output>
