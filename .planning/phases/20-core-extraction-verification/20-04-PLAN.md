---
phase: 20-core-extraction-verification
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/ocr/ocr_router.py
  - backend/tests/unit/ocr/test_ocr_router.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Scanned document triggers GPU OCR service and extracts text successfully"
    - "GPU OCR results are merged back into document content"
    - "Fallback to Docling OCR still works when GPU unavailable"
  artifacts:
    - path: "backend/src/ocr/ocr_router.py"
      provides: "GPU OCR integration wiring"
      contains: "_merge_gpu_ocr_results"
    - path: "backend/tests/unit/ocr/test_ocr_router.py"
      provides: "Tests for GPU OCR integration"
      exports: ["test_scanned_pdf_uses_gpu_ocr"]
  key_links:
    - from: "backend/src/ocr/ocr_router.py"
      to: "gpu_client.extract_text"
      via: "_ocr_pages_with_gpu method"
      pattern: "await self._ocr_pages_with_gpu"
    - from: "backend/src/ocr/ocr_router.py"
      to: "DocumentContent"
      via: "_merge_gpu_ocr_results method"
      pattern: "DocumentContent\\(.*pages="
---

<objective>
Wire GPU OCR integration in OCRRouter to actually call the GPU service for scanned document pages

Purpose: Close gap identified in Phase 20 verification - GPU service deployed but never invoked for actual document OCR processing. TEST-05 requirement "GPU OCR service processes scanned document" is blocked.

Output: Backend OCRRouter calls GPU service extract_text() for scanned pages, merges OCR text back into document content, and passes TEST-05 verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-core-extraction-verification/20-VERIFICATION.md

# Gap analysis shows:
# 1. GPU service infrastructure complete and healthy
# 2. LightOnOCRClient code complete at backend/src/ocr/lightonocr_client.py
# 3. OCRRouter._try_gpu_ocr() and ._ocr_pages_with_gpu() methods exist but bypassed
# 4. Lines 255-264 of ocr_router.py do health check then fall back to Docling
# 5. Need to wire actual GPU OCR call path

@backend/src/ocr/ocr_router.py
@backend/src/ocr/lightonocr_client.py
@backend/src/ingestion/docling_processor.py
@backend/tests/unit/ocr/test_ocr_router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire GPU OCR integration in OCRRouter</name>
  <files>backend/src/ocr/ocr_router.py</files>
  <action>
Modify the process() method in OCRRouter to actually use GPU OCR for scanned pages instead of falling back to Docling.

**Current code at lines 245-264:**
1. Checks GPU health
2. Logs "GPU service healthy, using Docling OCR for full document"
3. Falls back to Docling OCR immediately

**Change to:**
1. Check GPU health (keep existing)
2. If healthy, call _ocr_pages_with_gpu() to OCR scanned pages via GPU
3. Merge OCR text results into DocumentContent using new _merge_gpu_ocr_results() method
4. Return OCRResult with ocr_method="gpu"
5. On GPU failure, fall back to Docling OCR (keep existing fallback)

**Implementation - Replace lines 254-264 with:**
```python
# GPU is healthy - use GPU OCR for scanned pages
logger.info("GPU service healthy, using GPU OCR for %d pages", len(detection.scanned_pages))
ocr_texts = await self._ocr_pages_with_gpu(pdf_bytes, detection.scanned_pages)

# Merge GPU OCR results into DocumentContent
content = self._merge_gpu_ocr_results(pdf_bytes, filename, ocr_texts, detection)
return OCRResult(
    content=content,
    ocr_method="gpu",
    pages_ocrd=detection.scanned_pages,
)
```

**Add new method _merge_gpu_ocr_results() after _ocr_pages_with_gpu():**
```python
def _merge_gpu_ocr_results(
    self,
    pdf_bytes: bytes,
    filename: str,
    ocr_texts: dict[int, str],
    detection: DetectionResult,
) -> DocumentContent:
    """Merge GPU OCR results with native PDF text extraction.

    Strategy:
    - For scanned pages: Use GPU OCR text from ocr_texts dict
    - For native pages: Use Docling without OCR to extract text
    - Combine into unified DocumentContent

    Args:
        pdf_bytes: Raw PDF bytes
        filename: Original filename
        ocr_texts: Dict mapping page index (0-based) to GPU OCR'd text
        detection: Detection result with page classification

    Returns:
        DocumentContent with merged text from all pages
    """
    from src.ingestion.docling_processor import PageContent, DocumentContent

    # Build page content list
    pages: list[PageContent] = []
    all_text_parts: list[str] = []

    # Get total page count from detection
    total_pages = detection.total_pages
    scanned_set = set(detection.scanned_pages)

    # For native pages, we need to extract text via Docling (no OCR)
    # Process once to get native page texts
    native_content: DocumentContent | None = None
    if len(scanned_set) < total_pages:
        # Some pages are native - extract them via Docling without OCR
        no_ocr_processor = DoclingProcessor(
            enable_ocr=False,
            enable_tables=self.docling.enable_tables,
            max_pages=self.docling.max_pages,
        )
        native_content = no_ocr_processor.process_bytes(pdf_bytes, filename)

    # Build merged content page by page
    for page_idx in range(total_pages):
        page_num = page_idx + 1  # 1-indexed for PageContent

        if page_idx in scanned_set:
            # Scanned page - use GPU OCR text
            page_text = ocr_texts.get(page_idx, "")
            pages.append(PageContent(
                page_number=page_num,
                text=page_text,
                tables=[],  # GPU OCR doesn't extract tables
            ))
            all_text_parts.append(f"## Page {page_num}\n\n{page_text}")
        else:
            # Native page - use Docling extraction
            if native_content and page_idx < len(native_content.pages):
                native_page = native_content.pages[page_idx]
                pages.append(PageContent(
                    page_number=page_num,
                    text=native_page.text,
                    tables=native_page.tables,
                ))
                all_text_parts.append(f"## Page {page_num}\n\n{native_page.text}")
            else:
                # Fallback: empty page
                pages.append(PageContent(
                    page_number=page_num,
                    text="",
                    tables=[],
                ))

    # Combine all text
    full_text = "\n\n".join(all_text_parts)

    # Collect all tables from native pages
    all_tables = []
    if native_content:
        all_tables = native_content.tables

    return DocumentContent(
        text=full_text,
        pages=pages,
        page_count=total_pages,
        tables=all_tables,
        metadata={
            "ocr_method": "gpu",
            "scanned_pages": detection.scanned_pages,
            "native_pages": [i for i in range(total_pages) if i not in scanned_set],
        },
    )
```

**Remove the outdated comment:**
Delete lines 246-249 that say "Phase 15 will wire full integration" since we're completing the integration now.
  </action>
  <verify>
1. Verify no syntax errors:
   `cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr.ocr_router import OCRRouter; print('Import OK')"`

2. Verify _merge_gpu_ocr_results exists:
   `grep -n "_merge_gpu_ocr_results" /Users/gregorydickson/stackpoint/loan/backend/src/ocr/ocr_router.py`

3. Verify GPU OCR path is wired (no more "using Docling OCR for full document" when GPU healthy):
   `grep -n "using GPU OCR for" /Users/gregorydickson/stackpoint/loan/backend/src/ocr/ocr_router.py`

4. Run unit tests:
   `cd /Users/gregorydickson/stackpoint/loan && python -m pytest backend/tests/unit/ocr/test_ocr_router.py -v`
  </verify>
  <done>
- OCRRouter.process() calls _ocr_pages_with_gpu() when GPU is healthy
- _merge_gpu_ocr_results() method exists and builds DocumentContent from GPU OCR texts
- Returns OCRResult with ocr_method="gpu"
- No "Phase 15 will wire" comments remain
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test coverage for GPU OCR integration</name>
  <files>backend/tests/unit/ocr/test_ocr_router.py</files>
  <action>
Add test case to verify GPU OCR is actually invoked (not just health checked) when processing scanned documents.

**Add new test method test_scanned_pdf_uses_gpu_ocr in TestOCRRouter class:**
```python
@pytest.mark.asyncio
async def test_scanned_pdf_uses_gpu_ocr(
    self, router, mock_detector, mock_gpu_client, mock_docling
):
    """Test that scanned PDF pages are sent to GPU OCR service.

    This test uses a mock setup with 2 scanned pages. The assertions
    verify that extract_text is called once per scanned page.
    """
    # Arrange
    mock_detector.detect.return_value = DetectionResult(
        needs_ocr=True,
        scanned_pages=[0, 1],  # 2 scanned pages for this test
        total_pages=2,
        scanned_ratio=1.0,
    )
    mock_gpu_client.health_check.return_value = True
    mock_gpu_client.extract_text.return_value = "OCR extracted text from GPU"

    # Mock _page_to_png to avoid actual PDF processing
    with patch.object(router, '_page_to_png', return_value=b'fake png bytes'):
        result = await router.process(b"fake pdf", "scanned.pdf", mode="auto")

    # Assert
    assert result.ocr_method == "gpu"
    assert result.pages_ocrd == [0, 1]
    # Verify GPU extract_text was actually called (not just health_check)
    assert mock_gpu_client.extract_text.called
    # Call count matches number of scanned pages in this test setup
    assert mock_gpu_client.extract_text.call_count == 2
```

**Update existing test test_auto_mode_scanned_pdf_with_healthy_gpu:**
The existing test at lines 136-156 expects `ocr_method == "docling"` but should now expect `ocr_method == "gpu"` when GPU is healthy.

Change line 155 from:
```python
assert result.ocr_method == "docling"  # Using Docling's OCR for now
```
To:
```python
assert result.ocr_method == "gpu"  # GPU OCR is now wired
```

Also need to mock _page_to_png and ensure the test properly handles the new GPU OCR path:
```python
@pytest.mark.asyncio
async def test_auto_mode_scanned_pdf_with_healthy_gpu(
    self, router, mock_detector, mock_gpu_client
):
    """mode='auto' uses GPU OCR for scanned PDFs when GPU is healthy."""
    mock_detector.detect.return_value = DetectionResult(
        needs_ocr=True,
        scanned_pages=[0, 1],
        total_pages=2,
        scanned_ratio=1.0,
    )
    mock_gpu_client.health_check.return_value = True
    mock_gpu_client.extract_text.return_value = "GPU OCR text"

    with patch.object(router, '_page_to_png', return_value=b'fake png'):
        result = await router.process(b"fake pdf", "scanned.pdf", mode="auto")

    assert result.ocr_method == "gpu"  # GPU OCR is now wired
    assert result.pages_ocrd == [0, 1]
    assert mock_gpu_client.extract_text.call_count == 2
```

**Update test_force_mode_always_ocr:**
Similarly update to expect GPU OCR when healthy. Change line 202 from `assert result.ocr_method == "docling"` to `assert result.ocr_method == "gpu"` and add mock for _page_to_png.
  </action>
  <verify>
Run full OCR router test suite:
`cd /Users/gregorydickson/stackpoint/loan && python -m pytest backend/tests/unit/ocr/test_ocr_router.py -v`

Confirm:
1. New test test_scanned_pdf_uses_gpu_ocr passes
2. Updated test test_auto_mode_scanned_pdf_with_healthy_gpu passes with ocr_method=="gpu"
3. No test regressions
  </verify>
  <done>
- Test test_scanned_pdf_uses_gpu_ocr exists and passes
- Existing tests updated to expect GPU OCR when healthy
- All OCR router tests pass
  </done>
</task>

</tasks>

<verification>
## Gap Closure Verification

After all tasks complete:

1. **Code verification:**
   - `grep -c "_merge_gpu_ocr_results" backend/src/ocr/ocr_router.py` returns 2+ (definition + call)
   - `grep "ocr_method=\"gpu\"" backend/src/ocr/ocr_router.py` shows GPU return path
   - `grep -c "Phase 15 will wire" backend/src/ocr/ocr_router.py` returns 0

2. **Merge verification:**
   - `grep -A 5 "_merge_gpu_ocr_results" backend/src/ocr/ocr_router.py | grep "DocumentContent"` confirms merge creates DocumentContent
   - `grep "pages:" backend/src/ocr/ocr_router.py` shows pages list is built

3. **Test verification:**
   - `python -m pytest backend/tests/unit/ocr/test_ocr_router.py::TestOCRRouter::test_scanned_pdf_uses_gpu_ocr -v` passes
   - `python -m pytest backend/tests/unit/ocr/test_ocr_router.py -v` all tests pass

4. **Fallback verification:**
   - Docling fallback tests still pass (test_fallback_on_gpu_unhealthy, test_fallback_on_light_onocr_error)
   - Circuit breaker protection intact
</verification>

<success_criteria>
- [ ] OCRRouter._ocr_pages_with_gpu() called when GPU is healthy and document has scanned pages
- [ ] _merge_gpu_ocr_results() method exists and builds DocumentContent correctly
- [ ] OCRResult.ocr_method == "gpu" when GPU OCR used successfully
- [ ] Test test_scanned_pdf_uses_gpu_ocr passes
- [ ] Backend unit tests pass (no regressions)
- [ ] TEST-05 requirement blocked by code gap is now unblocked (deployment verification is separate)
</success_criteria>

<output>
After completion, create `.planning/phases/20-core-extraction-verification/20-04-SUMMARY.md`
</output>
