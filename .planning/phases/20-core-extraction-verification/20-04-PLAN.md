---
phase: 20-core-extraction-verification
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/ocr/ocr_router.py
  - backend/tests/unit/ocr/test_ocr_router.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Scanned document triggers GPU OCR service and extracts text successfully"
    - "GPU OCR results are merged back into document content"
    - "Fallback to Docling OCR still works when GPU unavailable"
  artifacts:
    - path: "backend/src/ocr/ocr_router.py"
      provides: "GPU OCR integration wiring"
      contains: "_merge_gpu_ocr_results"
    - path: "backend/tests/unit/ocr/test_ocr_router.py"
      provides: "Tests for GPU OCR integration"
      exports: ["test_scanned_pdf_uses_gpu_ocr", "test_gpu_unavailable_falls_back_to_docling"]
  key_links:
    - from: "backend/src/ocr/ocr_router.py"
      to: "gpu_client.extract_text"
      via: "_ocr_pages_with_gpu method"
      pattern: "await self._ocr_pages_with_gpu"
    - from: "backend/src/ocr/ocr_router.py"
      to: "DocumentContent"
      via: "_merge_gpu_ocr_results method"
      pattern: "DocumentContent\\(.*pages="
---

<objective>
Wire GPU OCR integration in OCRRouter to actually call the GPU service for scanned document pages

Purpose: Close gap identified in Phase 20 verification - GPU service deployed but never invoked for actual document OCR processing. TEST-05 requirement "GPU OCR service processes scanned document" is blocked.

Output: Backend OCRRouter calls GPU service extract_text() for scanned pages, merges OCR text back into document content, and passes TEST-05 verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-core-extraction-verification/20-VERIFICATION.md

# Gap analysis shows:
# 1. GPU service infrastructure complete and healthy
# 2. LightOnOCRClient code complete at backend/src/ocr/lightonocr_client.py
# 3. OCRRouter._try_gpu_ocr() and ._ocr_pages_with_gpu() methods exist but bypassed
# 4. Lines 255-264 of ocr_router.py do health check then fall back to Docling
# 5. Need to wire actual GPU OCR call path

@backend/src/ocr/ocr_router.py
@backend/src/ocr/lightonocr_client.py
@backend/src/ingestion/docling_processor.py
@backend/tests/unit/ocr/test_ocr_router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire GPU OCR call path in process() method</name>
  <files>backend/src/ocr/ocr_router.py</files>
  <action>
**Pre-verification:** Before modifying, confirm GPU service endpoint is configured:
```bash
grep -r "LIGHTONOCR\|GPU_OCR" backend/.env* backend/src/config/ 2>/dev/null || echo "Check settings.py for GPU config"
```

Modify the process() method in OCRRouter to actually use GPU OCR for scanned pages instead of falling back to Docling.

**Current code at lines 254-264:**
1. Logs "GPU service healthy, using Docling OCR for full document"
2. Falls back to Docling OCR immediately

**Replace lines 254-264 with:**
```python
# GPU is healthy - use GPU OCR for scanned pages
logger.info("GPU service healthy, using GPU OCR for %d pages", len(detection.scanned_pages))
ocr_texts = await self._ocr_pages_with_gpu(pdf_bytes, detection.scanned_pages)

# Merge GPU OCR results into DocumentContent
content = self._merge_gpu_ocr_results(pdf_bytes, filename, ocr_texts, detection)
return OCRResult(
    content=content,
    ocr_method="gpu",
    pages_ocrd=detection.scanned_pages,
)
```

**Remove the outdated comment:**
Delete lines 246-249 that say "Phase 15 will wire full integration" since we're completing the integration now.
  </action>
  <verify>
1. Verify no syntax errors by importing the module:
   `cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr.ocr_router import OCRRouter; print('Import OK')"`

2. Verify GPU OCR path is wired (no more "using Docling OCR for full document" when GPU healthy):
   `grep -n "using GPU OCR for" /Users/gregorydickson/stackpoint/loan/backend/src/ocr/ocr_router.py`
  </verify>
  <done>
- OCRRouter.process() calls _ocr_pages_with_gpu() when GPU is healthy
- Returns OCRResult with ocr_method="gpu"
- No "Phase 15 will wire" comments remain
  </done>
</task>

<task type="auto">
  <name>Task 2: Add _merge_gpu_ocr_results method</name>
  <files>backend/src/ocr/ocr_router.py</files>
  <action>
Add new method _merge_gpu_ocr_results() after _ocr_pages_with_gpu() method (after line 173).

**IMPORTANT - Dependency Design:**
- Do NOT create a new DoclingProcessor instance inside this method
- For native page extraction, use self.docling (the existing instance passed to OCRRouter)
- This avoids circular dependency: OCRRouter already depends on DoclingProcessor via constructor injection

```python
def _merge_gpu_ocr_results(
    self,
    pdf_bytes: bytes,
    filename: str,
    ocr_texts: dict[int, str],
    detection: DetectionResult,
) -> DocumentContent:
    """Merge GPU OCR results with native PDF text extraction.

    Strategy:
    - For scanned pages: Use GPU OCR text from ocr_texts dict
    - For native pages: Use Docling without OCR to extract text
    - Combine into unified DocumentContent

    Args:
        pdf_bytes: Raw PDF bytes
        filename: Original filename
        ocr_texts: Dict mapping page index (0-based) to GPU OCR'd text
        detection: Detection result with page classification

    Returns:
        DocumentContent with merged text from all pages
    """
    from src.ingestion.docling_processor import PageContent, DocumentContent

    # Build page content list
    pages: list[PageContent] = []
    all_text_parts: list[str] = []

    # Get total page count from detection
    total_pages = detection.total_pages
    scanned_set = set(detection.scanned_pages)

    # For native pages, extract via Docling without OCR
    # Use existing self.docling settings but with OCR disabled
    native_content: DocumentContent | None = None
    if len(scanned_set) < total_pages:
        # Some pages are native - extract them via Docling without OCR
        # Create temporary processor with OCR disabled, using self.docling config
        no_ocr_processor = DoclingProcessor(
            enable_ocr=False,
            enable_tables=self.docling.enable_tables,
            max_pages=self.docling.max_pages,
        )
        native_content = no_ocr_processor.process_bytes(pdf_bytes, filename)

    # Build merged content page by page
    for page_idx in range(total_pages):
        page_num = page_idx + 1  # 1-indexed for PageContent

        if page_idx in scanned_set:
            # Scanned page - use GPU OCR text
            page_text = ocr_texts.get(page_idx, "")
            pages.append(PageContent(
                page_number=page_num,
                text=page_text,
                tables=[],  # GPU OCR doesn't extract tables
            ))
            all_text_parts.append(f"## Page {page_num}\n\n{page_text}")
        else:
            # Native page - use Docling extraction
            if native_content and page_idx < len(native_content.pages):
                native_page = native_content.pages[page_idx]
                pages.append(PageContent(
                    page_number=page_num,
                    text=native_page.text,
                    tables=native_page.tables,
                ))
                all_text_parts.append(f"## Page {page_num}\n\n{native_page.text}")
            else:
                # Fallback: empty page
                pages.append(PageContent(
                    page_number=page_num,
                    text="",
                    tables=[],
                ))

    # Combine all text
    full_text = "\n\n".join(all_text_parts)

    # Collect all tables from native pages
    all_tables = []
    if native_content:
        all_tables = native_content.tables

    return DocumentContent(
        text=full_text,
        pages=pages,
        page_count=total_pages,
        tables=all_tables,
        metadata={
            "ocr_method": "gpu",
            "scanned_pages": detection.scanned_pages,
            "native_pages": [i for i in range(total_pages) if i not in scanned_set],
        },
    )
```

**Note on DoclingProcessor instantiation:** Creating a DoclingProcessor with `enable_ocr=False` for native page extraction is intentional and safe - it's a leaf dependency (DoclingProcessor doesn't depend on OCRRouter). The dependency flow is: OCRRouter -> DoclingProcessor, not circular.
  </action>
  <verify>
1. Verify no syntax errors by running full module import:
   `cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr.ocr_router import OCRRouter; r = OCRRouter.__dict__; print('_merge_gpu_ocr_results' in r)"`

2. Verify method compiles with no type errors (run mypy if available):
   `cd /Users/gregorydickson/stackpoint/loan/backend && python -m mypy src/ocr/ocr_router.py --ignore-missing-imports 2>/dev/null || python -c "from src.ocr.ocr_router import OCRRouter; print('Type check: import OK')"`

3. Verify _merge_gpu_ocr_results exists and returns DocumentContent:
   `grep -A 5 "def _merge_gpu_ocr_results" /Users/gregorydickson/stackpoint/loan/backend/src/ocr/ocr_router.py | head -6`
   `grep -n "return DocumentContent" /Users/gregorydickson/stackpoint/loan/backend/src/ocr/ocr_router.py`
  </verify>
  <done>
- _merge_gpu_ocr_results() method exists and compiles without errors
- Method builds DocumentContent from GPU OCR texts + native page extractions
- Uses self.docling settings for native page extraction (no circular dependency)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test coverage for GPU OCR integration and fallback</name>
  <files>backend/tests/unit/ocr/test_ocr_router.py</files>
  <action>
**First, verify current test structure:**
```bash
grep -n "def test_\|async def test_" /Users/gregorydickson/stackpoint/loan/backend/tests/unit/ocr/test_ocr_router.py | head -20
grep -n "_page_to_png" /Users/gregorydickson/stackpoint/loan/backend/tests/unit/ocr/test_ocr_router.py
```

**Add new test method test_scanned_pdf_uses_gpu_ocr in TestOCRRouter class (after test_fallback_on_circuit_breaker_open around line 250):**
```python
@pytest.mark.asyncio
async def test_scanned_pdf_uses_gpu_ocr(
    self, router, mock_detector, mock_gpu_client, mock_docling
):
    """Test that scanned PDF pages are sent to GPU OCR service.

    This test verifies GPU OCR is actually invoked (not just health checked)
    when processing scanned documents. Uses a mock setup with 2 scanned pages.
    """
    # Arrange
    mock_detector.detect.return_value = DetectionResult(
        needs_ocr=True,
        scanned_pages=[0, 1],  # 2 scanned pages for this test
        total_pages=2,
        scanned_ratio=1.0,
    )
    mock_gpu_client.health_check.return_value = True
    mock_gpu_client.extract_text.return_value = "OCR extracted text from GPU"

    # Mock _page_to_png to avoid actual PDF processing
    with patch.object(router, '_page_to_png', return_value=b'fake png bytes'):
        result = await router.process(b"fake pdf", "scanned.pdf", mode="auto")

    # Assert
    assert result.ocr_method == "gpu"
    assert result.pages_ocrd == [0, 1]
    # Verify GPU extract_text was actually called (not just health_check)
    assert mock_gpu_client.extract_text.called
    # Call count matches number of scanned pages in this test setup
    assert mock_gpu_client.extract_text.call_count == 2
```

**Add test for GPU unavailable fallback (covers must_haves truth: "Fallback to Docling OCR still works"):**
```python
@pytest.mark.asyncio
async def test_gpu_unavailable_falls_back_to_docling(
    self, router, mock_detector, mock_gpu_client
):
    """Test fallback to Docling when GPU service is unhealthy.

    This explicitly tests the fallback path when GPU health check fails,
    ensuring Docling OCR is used as a backup.
    """
    mock_detector.detect.return_value = DetectionResult(
        needs_ocr=True,
        scanned_pages=[0],
        total_pages=1,
        scanned_ratio=1.0,
    )
    # GPU is unhealthy
    mock_gpu_client.health_check.return_value = False

    with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
        mock_instance = MagicMock()
        mock_instance.process_bytes.return_value = MagicMock(text="Docling fallback text")
        MockProcessor.return_value = mock_instance

        result = await router.process(b"fake pdf", "scanned.pdf", mode="auto")

        # Should fall back to Docling
        assert result.ocr_method == "docling"
        # GPU extract_text should NOT have been called
        assert not mock_gpu_client.extract_text.called
        # Docling OCR should have been invoked
        MockProcessor.assert_called()
        call_kwargs = MockProcessor.call_args[1]
        assert call_kwargs["enable_ocr"] is True
```

**Update existing test test_auto_mode_scanned_pdf_with_healthy_gpu (lines 136-156):**
The existing test expects `ocr_method == "docling"` but should now expect `ocr_method == "gpu"`.

Replace the entire test method with:
```python
@pytest.mark.asyncio
async def test_auto_mode_scanned_pdf_with_healthy_gpu(
    self, router, mock_detector, mock_gpu_client
):
    """mode='auto' uses GPU OCR for scanned PDFs when GPU is healthy."""
    mock_detector.detect.return_value = DetectionResult(
        needs_ocr=True,
        scanned_pages=[0, 1],
        total_pages=2,
        scanned_ratio=1.0,
    )
    mock_gpu_client.health_check.return_value = True
    mock_gpu_client.extract_text.return_value = "GPU OCR text"

    with patch.object(router, '_page_to_png', return_value=b'fake png'):
        result = await router.process(b"fake pdf", "scanned.pdf", mode="auto")

    assert result.ocr_method == "gpu"  # GPU OCR is now wired
    assert result.pages_ocrd == [0, 1]
    assert mock_gpu_client.extract_text.call_count == 2
```

**Update test_force_mode_always_ocr (lines 185-203):**
Similarly update to expect GPU OCR when healthy. Replace with:
```python
@pytest.mark.asyncio
async def test_force_mode_always_ocr(self, router, mock_gpu_client):
    """mode='force' always runs OCR via GPU when healthy."""
    mock_gpu_client.health_check.return_value = True
    mock_gpu_client.extract_text.return_value = "Force GPU OCR text"

    with patch("src.ocr.ocr_router.pdfium.PdfDocument") as MockPdf:
        mock_pdf = MagicMock()
        mock_pdf.__len__ = MagicMock(return_value=2)
        MockPdf.return_value = mock_pdf

        with patch.object(router, '_page_to_png', return_value=b'fake png'):
            result = await router.process(b"fake pdf", "force.pdf", mode="force")

    # Should have OCR'd both pages via GPU
    assert result.ocr_method == "gpu"
    assert len(result.pages_ocrd) == 2
    assert mock_gpu_client.extract_text.call_count == 2
```
  </action>
  <verify>
Run full OCR router test suite:
`cd /Users/gregorydickson/stackpoint/loan && python -m pytest backend/tests/unit/ocr/test_ocr_router.py -v`

Confirm:
1. New test test_scanned_pdf_uses_gpu_ocr passes
2. New test test_gpu_unavailable_falls_back_to_docling passes
3. Updated test test_auto_mode_scanned_pdf_with_healthy_gpu passes with ocr_method=="gpu"
4. Updated test test_force_mode_always_ocr passes with ocr_method=="gpu"
5. Existing fallback tests still pass (test_auto_mode_fallback_on_gpu_unhealthy, test_fallback_on_light_onocr_error, test_fallback_on_circuit_breaker_open)
6. No test regressions
  </verify>
  <done>
- Test test_scanned_pdf_uses_gpu_ocr exists and passes
- Test test_gpu_unavailable_falls_back_to_docling exists and passes (covers fallback must_have truth)
- Existing tests updated to expect GPU OCR when healthy
- All OCR router tests pass
  </done>
</task>

</tasks>

<verification>
## Gap Closure Verification

After all tasks complete:

1. **Code verification:**
   - `cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr.ocr_router import OCRRouter; print('Import OK')"` succeeds
   - `grep -c "_merge_gpu_ocr_results" backend/src/ocr/ocr_router.py` returns 2+ (definition + call)
   - `grep "ocr_method=\"gpu\"" backend/src/ocr/ocr_router.py` shows GPU return path
   - `grep -c "Phase 15 will wire" backend/src/ocr/ocr_router.py` returns 0

2. **Merge verification:**
   - `grep -A 5 "_merge_gpu_ocr_results" backend/src/ocr/ocr_router.py | grep "DocumentContent"` confirms merge creates DocumentContent
   - `grep "pages:" backend/src/ocr/ocr_router.py` shows pages list is built

3. **Test verification:**
   - `python -m pytest backend/tests/unit/ocr/test_ocr_router.py::TestOCRRouter::test_scanned_pdf_uses_gpu_ocr -v` passes
   - `python -m pytest backend/tests/unit/ocr/test_ocr_router.py::TestOCRRouter::test_gpu_unavailable_falls_back_to_docling -v` passes
   - `python -m pytest backend/tests/unit/ocr/test_ocr_router.py -v` all tests pass

4. **Fallback verification:**
   - Docling fallback tests still pass (test_auto_mode_fallback_on_gpu_unhealthy, test_fallback_on_light_onocr_error, test_fallback_on_circuit_breaker_open)
   - New test_gpu_unavailable_falls_back_to_docling explicitly verifies fallback path
   - Circuit breaker protection intact
</verification>

<success_criteria>
- [ ] OCRRouter._ocr_pages_with_gpu() called when GPU is healthy and document has scanned pages
- [ ] _merge_gpu_ocr_results() method exists, compiles, and builds DocumentContent correctly
- [ ] No circular dependency - DoclingProcessor instantiation is safe (leaf dependency)
- [ ] OCRResult.ocr_method == "gpu" when GPU OCR used successfully
- [ ] Test test_scanned_pdf_uses_gpu_ocr passes
- [ ] Test test_gpu_unavailable_falls_back_to_docling passes (covers fallback must_have)
- [ ] Backend unit tests pass (no regressions)
- [ ] TEST-05 requirement blocked by code gap is now unblocked (deployment verification is separate)
</success_criteria>

<output>
After completion, create `.planning/phases/20-core-extraction-verification/20-04-SUMMARY.md`
</output>
