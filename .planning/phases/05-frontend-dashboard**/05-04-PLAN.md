---
phase: 05-frontend-dashboard
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/components/architecture/mermaid-diagram.tsx
  - frontend/src/components/architecture/decision-card.tsx
  - frontend/src/app/architecture/page.tsx
  - frontend/src/app/architecture/pipeline/page.tsx
  - frontend/src/app/architecture/scaling/page.tsx
  - frontend/src/app/architecture/decisions/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can view system architecture diagram on /architecture page"
    - "User can view pipeline flow diagram on /architecture/pipeline page"
    - "User can view scaling analysis on /architecture/scaling page"
    - "Mermaid diagrams render correctly without SSR errors"
  artifacts:
    - path: "frontend/src/components/architecture/mermaid-diagram.tsx"
      provides: "Client-side Mermaid diagram renderer"
      exports: ["MermaidDiagram"]
    - path: "frontend/src/app/architecture/page.tsx"
      provides: "Architecture overview page with system diagram"
      min_lines: 40
    - path: "frontend/src/app/architecture/pipeline/page.tsx"
      provides: "Pipeline flow diagram page"
      min_lines: 30
    - path: "frontend/src/app/architecture/scaling/page.tsx"
      provides: "Scaling analysis page"
      min_lines: 40
  key_links:
    - from: "frontend/src/components/architecture/mermaid-diagram.tsx"
      to: "mermaid"
      via: "Import and initialize mermaid in useEffect"
      pattern: "mermaid\\.initialize"
    - from: "frontend/src/app/architecture/page.tsx"
      to: "frontend/src/components/architecture/mermaid-diagram.tsx"
      via: "MermaidDiagram component"
      pattern: "MermaidDiagram"
---

<objective>
Build the architecture documentation pages with Mermaid diagrams for system overview, pipeline flow, and scaling analysis.

Purpose: Visualize system architecture, data pipeline, and scaling strategy (Success Criteria #4).
Output: Working /architecture pages with rendered Mermaid diagrams and decision records.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-frontend-dashboard**/05-RESEARCH.md
@.planning/phases/05-frontend-dashboard**/05-01-SUMMARY.md

Key architecture info from PROJECT.md:
- Docling for document processing
- Gemini 3.0 with Flash/Pro model selection
- PostgreSQL for storage
- FastAPI backend, Next.js frontend
- GCP Cloud Run deployment target
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mermaid diagram component</name>
  <files>frontend/src/components/architecture/mermaid-diagram.tsx</files>
  <action>
    Create `components/architecture/mermaid-diagram.tsx`:
    - "use client" directive (CRITICAL - Mermaid requires browser APIs)
    - Import mermaid from "mermaid"
    - Props: chart: string, className?: string
    - Use useRef for container div
    - Use useEffect to:
      1. Initialize mermaid with { startOnLoad: false, theme: "neutral" }
      2. Call mermaid.run({ nodes: [containerRef.current] })
    - Re-run when chart prop changes
    - Return div with ref and className="mermaid" containing chart string

    Handle SSR gracefully:
    - The "use client" directive ensures this only runs in browser
    - Mermaid.initialize should happen inside useEffect, not at module level

    Example usage:
    ```tsx
    <MermaidDiagram
      chart={`
        graph TB
          A[Frontend] --> B[API]
          B --> C[Database]
      `}
      className="p-4 bg-white rounded-lg"
    />
    ```

    Add error boundary or try-catch in useEffect to handle invalid chart syntax gracefully.
  </action>
  <verify>
    Create a test page that renders MermaidDiagram - should show diagram without SSR errors.
  </verify>
  <done>MermaidDiagram component renders Mermaid charts client-side without SSR errors</done>
</task>

<task type="auto">
  <name>Task 2: Create architecture overview and decision pages</name>
  <files>
    frontend/src/components/architecture/decision-card.tsx
    frontend/src/app/architecture/page.tsx
    frontend/src/app/architecture/decisions/page.tsx
  </files>
  <action>
    Create `components/architecture/decision-card.tsx`:
    - Props: title, decision, rationale, status ("pending" | "adopted")
    - Use Card component
    - Show title, decision text, rationale
    - Badge for status

    Create `app/architecture/page.tsx`:
    - Page title: "System Architecture"
    - Navigation tabs/links to sub-pages (Pipeline, Scaling, Decisions)
    - Main content: System architecture diagram

    Mermaid chart for system overview:
    ```mermaid
    graph TB
        subgraph Frontend["Frontend (Next.js)"]
            UI[Dashboard UI]
            Upload[Document Upload]
            Browse[Borrower Browser]
        end

        subgraph Backend["Backend (FastAPI)"]
            API[REST API]
            Service[Document Service]
            Extraction[Extraction Engine]
        end

        subgraph Processing["Document Processing"]
            Docling[Docling Parser]
            Gemini[Gemini LLM]
            Validator[Data Validator]
        end

        subgraph Storage["Data Storage"]
            PostgreSQL[(PostgreSQL)]
            GCS[Cloud Storage]
        end

        UI --> API
        Upload --> API
        Browse --> API
        API --> Service
        Service --> Docling
        Service --> GCS
        Extraction --> Gemini
        Extraction --> Validator
        API --> PostgreSQL
    ```

    Create `app/architecture/decisions/page.tsx`:
    - Page title: "Architecture Decisions"
    - List of DecisionCard components for each key decision from PROJECT.md:
      1. Docling for document processing
      2. Gemini 3.0 with dynamic model selection
      3. PostgreSQL over NoSQL
      4. FastAPI over Flask/Django
      5. Next.js 14 App Router
      6. Cloud Run over GKE
      7. Test-first TDD approach
  </action>
  <verify>
    Navigate to /architecture - system diagram renders.
    Navigate to /architecture/decisions - decision cards display.
  </verify>
  <done>Architecture overview page shows system diagram; decisions page lists ADRs</done>
</task>

<task type="auto">
  <name>Task 3: Create pipeline and scaling pages</name>
  <files>
    frontend/src/app/architecture/pipeline/page.tsx
    frontend/src/app/architecture/scaling/page.tsx
  </files>
  <action>
    Create `app/architecture/pipeline/page.tsx`:
    - Page title: "Data Pipeline"
    - Description of document processing flow
    - Mermaid sequence/flowchart diagram:

    ```mermaid
    sequenceDiagram
        participant User
        participant Frontend
        participant API
        participant Docling
        participant GCS
        participant Gemini
        participant PostgreSQL

        User->>Frontend: Upload Document
        Frontend->>API: POST /api/documents
        API->>GCS: Store Original File
        API->>Docling: Process Document
        Docling->>API: Extracted Text + Pages
        API->>PostgreSQL: Save Document Record
        API->>Frontend: Document ID + Status

        Note over API,Gemini: Extraction Phase
        API->>Gemini: Send Document Text
        Gemini->>API: Structured Borrower Data
        API->>PostgreSQL: Save Borrowers + Sources
    ```

    Add text sections explaining:
    - Document ingestion flow
    - Text extraction with Docling
    - LLM extraction with Gemini
    - Source attribution tracking

    Create `app/architecture/scaling/page.tsx`:
    - Page title: "Scaling Analysis"
    - Content sections:
      1. Current Capacity: Single Cloud Run instance, ~10 concurrent uploads
      2. 10x Scale: Multiple Cloud Run instances, Cloud Tasks queue, ~100 documents/hour
      3. 100x Scale: Dedicated workers, Redis caching, batch processing, ~1000 documents/hour
    - Include cost projections table (rough estimates)
    - Mermaid diagram for scaled architecture:

    ```mermaid
    graph LR
        subgraph "Load Balanced"
            LB[Cloud Load Balancer]
            CR1[Cloud Run 1]
            CR2[Cloud Run 2]
            CR3[Cloud Run N]
        end

        subgraph "Async Processing"
            CT[Cloud Tasks]
            Worker1[Worker 1]
            Worker2[Worker N]
        end

        subgraph "Shared Services"
            Redis[(Redis Cache)]
            CloudSQL[(Cloud SQL)]
            GCS[Cloud Storage]
        end

        LB --> CR1
        LB --> CR2
        LB --> CR3
        CR1 --> CT
        CT --> Worker1
        CT --> Worker2
        Worker1 --> CloudSQL
        Worker2 --> CloudSQL
        Worker1 --> GCS
        Redis -.-> CR1
        Redis -.-> CR2
    ```

    Use Cards for each scale tier with title, description, and architecture changes.
  </action>
  <verify>
    Navigate to /architecture/pipeline - pipeline diagram and description render.
    Navigate to /architecture/scaling - scaling tiers and diagram render.
  </verify>
  <done>Pipeline page shows data flow diagram; scaling page shows tiered scaling analysis</done>
</task>

</tasks>

<verification>
1. Navigate to /architecture - system diagram renders without errors
2. Navigate to /architecture/decisions - ADR cards display
3. Navigate to /architecture/pipeline - sequence diagram renders
4. Navigate to /architecture/scaling - scaling tiers and diagram render
5. All Mermaid diagrams render without SSR errors (no "document is not defined")
6. Pages are responsive and readable on tablet
</verification>

<success_criteria>
- /architecture shows system architecture Mermaid diagram
- /architecture/pipeline shows data flow diagram with explanation
- /architecture/scaling shows 3 scaling tiers with cost estimates
- /architecture/decisions shows ADR cards for key decisions
- All diagrams render client-side without SSR errors
- Navigation between architecture sub-pages works
- Pages render correctly on desktop and tablet
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-dashboard**/05-04-SUMMARY.md`
</output>
