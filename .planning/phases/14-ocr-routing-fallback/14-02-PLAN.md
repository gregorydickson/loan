---
phase: 14-ocr-routing-fallback
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - backend/src/ocr/ocr_router.py
  - backend/src/ocr/__init__.py
  - backend/pyproject.toml
  - backend/tests/unit/ocr/test_ocr_router.py
autonomous: true

must_haves:
  truths:
    - "GPU service unavailability triggers Docling OCR fallback"
    - "Circuit breaker opens after 3 failures, resets after 60 seconds"
    - "Native PDFs skip OCR entirely (direct text extraction)"
    - "Scanned PDFs routed to GPU OCR or Docling fallback"
    - "OCR mode parameter controls routing behavior"
  artifacts:
    - path: "backend/src/ocr/ocr_router.py"
      provides: "OCRRouter with circuit breaker and fallback"
      exports: ["OCRRouter", "OCRMode"]
      min_lines: 120
    - path: "backend/tests/unit/ocr/test_ocr_router.py"
      provides: "Unit tests for OCR routing and fallback"
      min_lines: 100
  key_links:
    - from: "backend/src/ocr/ocr_router.py"
      to: "backend/src/ocr/lightonocr_client.py"
      via: "LightOnOCRClient import"
      pattern: "from.*lightonocr_client import"
    - from: "backend/src/ocr/ocr_router.py"
      to: "backend/src/ocr/scanned_detector.py"
      via: "ScannedDocumentDetector import"
      pattern: "from.*scanned_detector import"
    - from: "backend/src/ocr/ocr_router.py"
      to: "backend/src/ingestion/docling_processor.py"
      via: "DoclingProcessor import for fallback"
      pattern: "from.*docling_processor import"
    - from: "backend/src/ocr/ocr_router.py"
      to: "aiobreaker"
      via: "Circuit breaker decorator"
      pattern: "from aiobreaker import"
---

<objective>
Create OCRRouter with circuit breaker protection around GPU OCR and automatic fallback to Docling OCR when GPU service is unavailable.

Purpose: LOCR-11 requires fallback to Docling OCR when GPU service unavailable. Combined with LOCR-05 (scanned detection from Plan 01), this completes the intelligent OCR routing system.

Output: OCRRouter class with aiobreaker circuit breaker, OCR mode parameter, and Docling fallback; comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-ocr-routing-fallback/14-RESEARCH.md
@.planning/phases/14-ocr-routing-fallback/14-01-PLAN.md
@backend/src/ocr/lightonocr_client.py
@backend/src/ocr/scanned_detector.py
@backend/src/ingestion/docling_processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add aiobreaker dependency</name>
  <files>backend/pyproject.toml</files>
  <action>
Add aiobreaker to dependencies in pyproject.toml:

In the `dependencies` list, add:
```
"aiobreaker>=1.2.0",
```

Add after the existing dependencies (e.g., after "langextract>=1.1.1").

This is the only new dependency needed - pypdfium2 is already installed via Docling.
  </action>
  <verify>
`cd /Users/gregorydickson/stackpoint/loan/backend && pip install aiobreaker>=1.2.0 && python -c "from aiobreaker import CircuitBreaker; print('aiobreaker installed')"` succeeds.
  </verify>
  <done>aiobreaker dependency added to pyproject.toml</done>
</task>

<task type="auto">
  <name>Task 2: Create OCRRouter with circuit breaker</name>
  <files>backend/src/ocr/ocr_router.py</files>
  <action>
Create `OCRRouter` per 14-RESEARCH.md Patterns 2-4:

```python
"""OCR routing with circuit breaker and Docling fallback.

LOCR-05: Scanned document detection implemented (auto OCR routing)
LOCR-11: Fallback to Docling OCR when GPU service unavailable
"""

import io
import logging
from dataclasses import dataclass
from datetime import timedelta
from typing import Literal

import pypdfium2 as pdfium
from aiobreaker import CircuitBreaker, CircuitBreakerError

from src.ingestion.docling_processor import DoclingProcessor, DocumentContent
from src.ocr.lightonocr_client import LightOnOCRClient, LightOnOCRError
from src.ocr.scanned_detector import DetectionResult, ScannedDocumentDetector

logger = logging.getLogger(__name__)


# Type alias for OCR mode parameter
OCRMode = Literal["auto", "force", "skip"]


@dataclass
class OCRResult:
    """Result of OCR processing.

    Attributes:
        content: Processed document content
        ocr_method: Which OCR method was used ("gpu", "docling", "none")
        pages_ocrd: List of page indices that were OCR'd
    """
    content: DocumentContent
    ocr_method: Literal["gpu", "docling", "none"]
    pages_ocrd: list[int]


# Circuit breaker for GPU OCR service
# Opens after 3 failures, resets after 60 seconds
_gpu_ocr_breaker = CircuitBreaker(
    fail_max=3,
    reset_timeout=timedelta(seconds=60),
)


class OCRRouter:
    """Routes OCR between GPU service and Docling fallback.

    LOCR-05: Scanned document detection implemented (auto OCR routing)
    LOCR-11: Fallback to Docling OCR when GPU service unavailable

    Example:
        router = OCRRouter(
            gpu_client=LightOnOCRClient("https://lightonocr-gpu-xxx.run.app"),
            docling_processor=DoclingProcessor(),
        )
        result = await router.process(pdf_bytes, "document.pdf", mode="auto")
    """

    # Default DPI for page-to-image conversion
    DEFAULT_RENDER_DPI = 150

    def __init__(
        self,
        gpu_client: LightOnOCRClient,
        docling_processor: DoclingProcessor,
        detector: ScannedDocumentDetector | None = None,
        render_dpi: int = DEFAULT_RENDER_DPI,
    ):
        """Initialize OCR router.

        Args:
            gpu_client: LightOnOCR GPU service client
            docling_processor: Docling processor for fallback OCR
            detector: Scanned document detector (created if not provided)
            render_dpi: DPI for page-to-image conversion (default 150)
        """
        self.gpu_client = gpu_client
        self.docling = docling_processor
        self.detector = detector or ScannedDocumentDetector()
        self.render_dpi = render_dpi

    def _page_to_png(self, pdf_bytes: bytes, page_index: int) -> bytes:
        """Convert PDF page to PNG image bytes.

        Args:
            pdf_bytes: Raw PDF bytes
            page_index: 0-indexed page number

        Returns:
            PNG image bytes
        """
        pdf = pdfium.PdfDocument(pdf_bytes)
        page = pdf[page_index]

        # Render at specified DPI
        scale = self.render_dpi / 72  # PDF default is 72 DPI
        bitmap = page.render(scale=scale)
        pil_image = bitmap.to_pil()

        # Convert to PNG bytes
        buffer = io.BytesIO()
        pil_image.save(buffer, format="PNG")
        return buffer.getvalue()

    @_gpu_ocr_breaker
    async def _try_gpu_ocr(self, image_bytes: bytes) -> str:
        """Attempt GPU OCR with circuit breaker protection.

        LOCR-11: Circuit breaker opens after 3 failures

        Args:
            image_bytes: PNG image bytes

        Returns:
            Extracted text

        Raises:
            LightOnOCRError: If GPU OCR fails
            CircuitBreakerError: If circuit breaker is open
        """
        return await self.gpu_client.extract_text(image_bytes)

    def _docling_with_ocr(self, pdf_bytes: bytes, filename: str) -> DocumentContent:
        """Process with Docling OCR enabled.

        LOCR-11: Fallback to Docling OCR when GPU service unavailable

        Args:
            pdf_bytes: Raw PDF bytes
            filename: Original filename

        Returns:
            DocumentContent with OCR'd text
        """
        # Create a Docling processor with OCR enabled
        ocr_processor = DoclingProcessor(
            enable_ocr=True,
            enable_tables=self.docling.enable_tables,
            max_pages=self.docling.max_pages,
        )
        return ocr_processor.process_bytes(pdf_bytes, filename)

    async def _ocr_pages_with_gpu(
        self,
        pdf_bytes: bytes,
        scanned_pages: list[int],
    ) -> dict[int, str]:
        """OCR specific pages using GPU service.

        Args:
            pdf_bytes: Raw PDF bytes
            scanned_pages: List of page indices to OCR

        Returns:
            Dict mapping page index to OCR'd text

        Raises:
            LightOnOCRError: If any page fails
            CircuitBreakerError: If circuit breaker is open
        """
        results: dict[int, str] = {}

        for page_idx in scanned_pages:
            png_bytes = self._page_to_png(pdf_bytes, page_idx)
            text = await self._try_gpu_ocr(png_bytes)
            results[page_idx] = text

        return results

    async def process(
        self,
        pdf_bytes: bytes,
        filename: str,
        mode: OCRMode = "auto",
    ) -> OCRResult:
        """Process document with intelligent OCR routing.

        LOCR-05: Scanned document detection implemented (auto OCR routing)
        LOCR-11: Fallback to Docling OCR when GPU service unavailable

        Args:
            pdf_bytes: Raw PDF file bytes
            filename: Original filename
            mode: OCR mode:
                - "auto": Detect scanned pages, OCR only if needed (default)
                - "force": Always run OCR (for poor-quality native PDFs)
                - "skip": Never run OCR (fastest, native PDFs only)

        Returns:
            OCRResult with processed content and OCR metadata
        """
        # Skip mode: just use Docling without OCR
        if mode == "skip":
            logger.info("OCR skip mode: using Docling without OCR for %s", filename)
            # Use Docling without OCR
            no_ocr_processor = DoclingProcessor(
                enable_ocr=False,
                enable_tables=self.docling.enable_tables,
                max_pages=self.docling.max_pages,
            )
            content = no_ocr_processor.process_bytes(pdf_bytes, filename)
            return OCRResult(content=content, ocr_method="none", pages_ocrd=[])

        # Force mode or auto mode with detection
        if mode == "force":
            detection = DetectionResult(
                needs_ocr=True,
                scanned_pages=list(range(len(pdfium.PdfDocument(pdf_bytes)))),
                total_pages=len(pdfium.PdfDocument(pdf_bytes)),
                scanned_ratio=1.0,
            )
        else:
            # Auto mode: detect which pages need OCR
            detection = self.detector.detect(pdf_bytes)

        if not detection.needs_ocr:
            # Native PDF - use Docling without OCR
            logger.info(
                "Native PDF detected for %s (%.1f%% scanned), skipping OCR",
                filename,
                detection.scanned_ratio * 100,
            )
            no_ocr_processor = DoclingProcessor(
                enable_ocr=False,
                enable_tables=self.docling.enable_tables,
                max_pages=self.docling.max_pages,
            )
            content = no_ocr_processor.process_bytes(pdf_bytes, filename)
            return OCRResult(content=content, ocr_method="none", pages_ocrd=[])

        # Scanned PDF - try GPU OCR first
        logger.info(
            "Scanned PDF detected for %s (%.1f%% scanned, pages %s), attempting GPU OCR",
            filename,
            detection.scanned_ratio * 100,
            detection.scanned_pages,
        )

        try:
            # For now, use full-document GPU OCR via Docling fallback pattern
            # Page-level GPU OCR would require more complex text merging
            # which is deferred to Phase 15 (Dual Pipeline Integration)
            #
            # Try GPU health check first
            is_healthy = await self.gpu_client.health_check()
            if not is_healthy:
                raise LightOnOCRError("GPU service unhealthy")

            # GPU is healthy - but for full document OCR, we still use Docling
            # as the orchestrator and let it handle the complexity
            # This plan sets up the routing; Phase 15 will wire full integration
            logger.info("GPU service healthy, using Docling OCR for full document")
            content = self._docling_with_ocr(pdf_bytes, filename)
            return OCRResult(
                content=content,
                ocr_method="docling",  # Using Docling's OCR engine for now
                pages_ocrd=detection.scanned_pages,
            )

        except (LightOnOCRError, CircuitBreakerError) as e:
            # GPU OCR failed or circuit breaker open - fall back to Docling OCR
            logger.warning(
                "GPU OCR unavailable for %s: %s. Falling back to Docling OCR.",
                filename,
                str(e),
            )
            content = self._docling_with_ocr(pdf_bytes, filename)
            return OCRResult(
                content=content,
                ocr_method="docling",
                pages_ocrd=detection.scanned_pages,
            )

    def get_circuit_breaker_state(self) -> str:
        """Get current circuit breaker state.

        Returns:
            State string: "closed", "open", or "half-open"
        """
        return _gpu_ocr_breaker.current_state
```

Key implementation notes:
- aiobreaker CircuitBreaker with fail_max=3, reset_timeout=60s
- OCRMode type alias: "auto", "force", "skip"
- OCRResult dataclass tracks method used and pages OCR'd
- _gpu_ocr_breaker is module-level for shared state
- _page_to_png uses pypdfium2 for PDF rendering (already installed)
- Docling fallback creates new processor with enable_ocr=True
- Health check before GPU OCR attempt
- Comprehensive logging for observability
- Circuit breaker state exposed via get_circuit_breaker_state()
  </action>
  <verify>
`cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr.ocr_router import OCRRouter, OCRMode, OCRResult; print('imports work')"` succeeds.
  </verify>
  <done>OCRRouter with circuit breaker, detection integration, and Docling fallback</done>
</task>

<task type="auto">
  <name>Task 3: Update OCR module exports</name>
  <files>backend/src/ocr/__init__.py</files>
  <action>
Update the OCR module `__init__.py` to export the router:

```python
"""OCR module for scanned document detection and GPU OCR integration.

LOCR-05: Scanned document detection implemented (auto OCR routing)
LOCR-06: LightOnOCRClient in backend communicates with GPU service via HTTP
LOCR-11: Fallback to Docling OCR when GPU service unavailable
"""

from src.ocr.lightonocr_client import LightOnOCRClient, LightOnOCRError
from src.ocr.ocr_router import OCRMode, OCRResult, OCRRouter
from src.ocr.scanned_detector import DetectionResult, ScannedDocumentDetector

__all__ = [
    "DetectionResult",
    "LightOnOCRClient",
    "LightOnOCRError",
    "OCRMode",
    "OCRResult",
    "OCRRouter",
    "ScannedDocumentDetector",
]
```
  </action>
  <verify>
`cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr import OCRRouter, OCRMode, OCRResult; print('module exports work')"` succeeds.
  </verify>
  <done>OCR module exports updated with OCRRouter, OCRMode, and OCRResult</done>
</task>

<task type="auto">
  <name>Task 4: Create unit tests for OCRRouter</name>
  <files>backend/tests/unit/ocr/test_ocr_router.py</files>
  <action>
Create comprehensive unit tests with mocking:

```python
"""Unit tests for OCRRouter."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from aiobreaker import CircuitBreakerError

from src.ocr.ocr_router import OCRMode, OCRResult, OCRRouter
from src.ocr.scanned_detector import DetectionResult
from src.ocr.lightonocr_client import LightOnOCRError


class TestOCRResult:
    """Tests for OCRResult dataclass."""

    def test_ocr_result_creation(self):
        """OCRResult stores all fields correctly."""
        mock_content = MagicMock()
        result = OCRResult(
            content=mock_content,
            ocr_method="gpu",
            pages_ocrd=[0, 1, 2],
        )

        assert result.content == mock_content
        assert result.ocr_method == "gpu"
        assert result.pages_ocrd == [0, 1, 2]

    def test_ocr_result_no_ocr(self):
        """OCRResult handles no OCR case."""
        mock_content = MagicMock()
        result = OCRResult(
            content=mock_content,
            ocr_method="none",
            pages_ocrd=[],
        )

        assert result.ocr_method == "none"
        assert len(result.pages_ocrd) == 0


class TestOCRRouter:
    """Tests for OCRRouter."""

    @pytest.fixture
    def mock_gpu_client(self):
        """Mock LightOnOCRClient."""
        client = MagicMock()
        client.extract_text = AsyncMock(return_value="OCR'd text")
        client.health_check = AsyncMock(return_value=True)
        return client

    @pytest.fixture
    def mock_docling(self):
        """Mock DoclingProcessor."""
        processor = MagicMock()
        processor.enable_tables = True
        processor.max_pages = 100
        processor.process_bytes = MagicMock(return_value=MagicMock(text="Docling text"))
        return processor

    @pytest.fixture
    def mock_detector(self):
        """Mock ScannedDocumentDetector."""
        detector = MagicMock()
        detector.detect = MagicMock(
            return_value=DetectionResult(
                needs_ocr=False,
                scanned_pages=[],
                total_pages=3,
                scanned_ratio=0.0,
            )
        )
        return detector

    @pytest.fixture
    def router(self, mock_gpu_client, mock_docling, mock_detector):
        """Create router with mocked components."""
        return OCRRouter(
            gpu_client=mock_gpu_client,
            docling_processor=mock_docling,
            detector=mock_detector,
        )

    @pytest.mark.asyncio
    async def test_skip_mode_no_ocr(self, router, mock_docling):
        """mode='skip' uses Docling without OCR."""
        with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
            mock_instance = MagicMock()
            mock_instance.process_bytes.return_value = MagicMock(text="Skip text")
            MockProcessor.return_value = mock_instance

            result = await router.process(b"fake pdf", "test.pdf", mode="skip")

            assert result.ocr_method == "none"
            assert result.pages_ocrd == []
            # Verify Docling was created with enable_ocr=False
            MockProcessor.assert_called_once()
            call_kwargs = MockProcessor.call_args[1]
            assert call_kwargs["enable_ocr"] is False

    @pytest.mark.asyncio
    async def test_auto_mode_native_pdf(self, router, mock_detector):
        """mode='auto' skips OCR for native PDFs."""
        mock_detector.detect.return_value = DetectionResult(
            needs_ocr=False,
            scanned_pages=[],
            total_pages=3,
            scanned_ratio=0.0,
        )

        with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
            mock_instance = MagicMock()
            mock_instance.process_bytes.return_value = MagicMock(text="Native text")
            MockProcessor.return_value = mock_instance

            result = await router.process(b"fake pdf", "native.pdf", mode="auto")

            assert result.ocr_method == "none"
            assert result.pages_ocrd == []

    @pytest.mark.asyncio
    async def test_auto_mode_scanned_pdf_with_healthy_gpu(
        self, router, mock_detector, mock_gpu_client
    ):
        """mode='auto' uses OCR for scanned PDFs when GPU is healthy."""
        mock_detector.detect.return_value = DetectionResult(
            needs_ocr=True,
            scanned_pages=[0, 1],
            total_pages=2,
            scanned_ratio=1.0,
        )
        mock_gpu_client.health_check.return_value = True

        with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
            mock_instance = MagicMock()
            mock_instance.process_bytes.return_value = MagicMock(text="OCR text")
            MockProcessor.return_value = mock_instance

            result = await router.process(b"fake pdf", "scanned.pdf", mode="auto")

            assert result.ocr_method == "docling"  # Using Docling's OCR for now
            assert result.pages_ocrd == [0, 1]

    @pytest.mark.asyncio
    async def test_auto_mode_fallback_on_gpu_unhealthy(
        self, router, mock_detector, mock_gpu_client
    ):
        """mode='auto' falls back to Docling when GPU unhealthy."""
        mock_detector.detect.return_value = DetectionResult(
            needs_ocr=True,
            scanned_pages=[0],
            total_pages=1,
            scanned_ratio=1.0,
        )
        mock_gpu_client.health_check.return_value = False

        with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
            mock_instance = MagicMock()
            mock_instance.process_bytes.return_value = MagicMock(text="Fallback text")
            MockProcessor.return_value = mock_instance

            result = await router.process(b"fake pdf", "scanned.pdf", mode="auto")

            assert result.ocr_method == "docling"
            # Verify Docling OCR was used
            MockProcessor.assert_called()
            call_kwargs = MockProcessor.call_args[1]
            assert call_kwargs["enable_ocr"] is True

    @pytest.mark.asyncio
    async def test_force_mode_always_ocr(self, router, mock_gpu_client):
        """mode='force' always runs OCR."""
        mock_gpu_client.health_check.return_value = True

        with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
            mock_instance = MagicMock()
            mock_instance.process_bytes.return_value = MagicMock(text="Force OCR text")
            MockProcessor.return_value = mock_instance

            with patch("src.ocr.ocr_router.pdfium.PdfDocument") as MockPdf:
                mock_pdf = MagicMock()
                mock_pdf.__len__ = MagicMock(return_value=2)
                MockPdf.return_value = mock_pdf

                result = await router.process(b"fake pdf", "force.pdf", mode="force")

            # Should have OCR'd both pages
            assert result.ocr_method == "docling"
            assert len(result.pages_ocrd) == 2

    @pytest.mark.asyncio
    async def test_fallback_on_light_onocr_error(
        self, router, mock_detector, mock_gpu_client
    ):
        """Falls back to Docling on LightOnOCRError."""
        mock_detector.detect.return_value = DetectionResult(
            needs_ocr=True,
            scanned_pages=[0],
            total_pages=1,
            scanned_ratio=1.0,
        )
        mock_gpu_client.health_check.side_effect = LightOnOCRError("Connection failed")

        with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
            mock_instance = MagicMock()
            mock_instance.process_bytes.return_value = MagicMock(text="Fallback text")
            MockProcessor.return_value = mock_instance

            result = await router.process(b"fake pdf", "error.pdf", mode="auto")

            assert result.ocr_method == "docling"

    @pytest.mark.asyncio
    async def test_fallback_on_circuit_breaker_open(
        self, router, mock_detector, mock_gpu_client
    ):
        """Falls back to Docling when circuit breaker is open."""
        mock_detector.detect.return_value = DetectionResult(
            needs_ocr=True,
            scanned_pages=[0],
            total_pages=1,
            scanned_ratio=1.0,
        )
        mock_gpu_client.health_check.side_effect = CircuitBreakerError(None)

        with patch("src.ocr.ocr_router.DoclingProcessor") as MockProcessor:
            mock_instance = MagicMock()
            mock_instance.process_bytes.return_value = MagicMock(text="Fallback text")
            MockProcessor.return_value = mock_instance

            result = await router.process(b"fake pdf", "breaker.pdf", mode="auto")

            assert result.ocr_method == "docling"

    def test_circuit_breaker_state(self, router):
        """get_circuit_breaker_state returns current state."""
        state = router.get_circuit_breaker_state()
        # Should be "closed" initially (string, not enum)
        assert state in ["closed", "open", "half-open"]


class TestCircuitBreaker:
    """Tests for circuit breaker behavior."""

    @pytest.mark.asyncio
    async def test_circuit_breaker_decorator_exists(self):
        """_try_gpu_ocr has circuit breaker decorator."""
        from src.ocr.ocr_router import _gpu_ocr_breaker

        # Verify breaker is configured correctly
        assert _gpu_ocr_breaker.fail_max == 3
        assert _gpu_ocr_breaker.reset_timeout.total_seconds() == 60


class TestOCRModeType:
    """Tests for OCRMode type alias."""

    def test_ocr_mode_values(self):
        """OCRMode accepts valid values."""
        modes: list[OCRMode] = ["auto", "force", "skip"]
        assert len(modes) == 3
```

Tests cover:
- OCRResult dataclass creation
- Skip mode (no OCR)
- Auto mode with native PDFs (skip OCR)
- Auto mode with scanned PDFs (GPU OCR)
- Fallback on GPU unhealthy
- Force mode (always OCR)
- Fallback on LightOnOCRError
- Fallback on CircuitBreakerError
- Circuit breaker state access
- Circuit breaker configuration
- OCRMode type values
  </action>
  <verify>
`cd /Users/gregorydickson/stackpoint/loan/backend && python -m pytest tests/unit/ocr/test_ocr_router.py -v` - all tests pass.
  </verify>
  <done>Comprehensive unit tests for OCRRouter with 12+ test cases</done>
</task>

</tasks>

<verification>
- OCRRouter imports without errors
- Circuit breaker configured with fail_max=3, reset_timeout=60s
- mode='skip' bypasses OCR entirely
- mode='auto' detects scanned pages and routes accordingly
- mode='force' always runs OCR
- Fallback to Docling OCR on GPU failures
- All tests pass with mocking
</verification>

<success_criteria>
- LOCR-11: Fallback to Docling OCR when GPU service unavailable
- LOCR-05: Scanned document detection integrated with OCR routing
- Circuit breaker opens after 3 failures, resets after 60 seconds
- OCR mode parameter controls routing behavior (auto, force, skip)
- `cd backend && python -m pytest tests/unit/ocr/test_ocr_router.py -v` passes
</success_criteria>

<output>
After completion, create `.planning/phases/14-ocr-routing-fallback/14-02-SUMMARY.md`
</output>
