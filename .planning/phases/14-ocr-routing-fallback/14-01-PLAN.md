---
phase: 14-ocr-routing-fallback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/ocr/scanned_detector.py
  - backend/src/ocr/__init__.py
  - backend/tests/unit/ocr/test_scanned_detector.py
autonomous: true

must_haves:
  truths:
    - "Scanned pages detected by text extraction ratio"
    - "Native PDFs with text layer identified correctly"
    - "Mixed documents (some scanned, some native pages) handled"
    - "Detection returns both document-level and page-level results"
  artifacts:
    - path: "backend/src/ocr/scanned_detector.py"
      provides: "ScannedDocumentDetector with text ratio detection"
      exports: ["ScannedDocumentDetector", "DetectionResult"]
      min_lines: 60
    - path: "backend/tests/unit/ocr/test_scanned_detector.py"
      provides: "Unit tests for scanned document detection"
      min_lines: 80
  key_links:
    - from: "backend/src/ocr/scanned_detector.py"
      to: "pypdfium2"
      via: "PDF text extraction"
      pattern: "import pypdfium2"
    - from: "backend/src/ocr/scanned_detector.py"
      to: "backend/src/ocr/__init__.py"
      via: "module export"
      pattern: "from.*scanned_detector import"
---

<objective>
Create ScannedDocumentDetector that identifies scanned/image-based PDF pages using text extraction ratio.

Purpose: LOCR-05 requires automatic scanned document detection for OCR routing. Native PDFs with text layers should skip GPU OCR, while scanned PDFs should be routed to LightOnOCR or Docling OCR.

Output: ScannedDocumentDetector class using pypdfium2 (already installed via Docling) with configurable thresholds; comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-ocr-routing-fallback/14-RESEARCH.md
@backend/src/ocr/lightonocr_client.py
@backend/src/ocr/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScannedDocumentDetector</name>
  <files>backend/src/ocr/scanned_detector.py</files>
  <action>
Create `ScannedDocumentDetector` per 14-RESEARCH.md Pattern 1:

```python
"""Scanned document detection via text extraction ratio.

LOCR-05: Scanned document detection implemented (auto OCR routing)
"""

from dataclasses import dataclass
import logging

import pypdfium2 as pdfium

logger = logging.getLogger(__name__)


@dataclass
class DetectionResult:
    """Result of scanned document detection.

    Attributes:
        needs_ocr: True if document should be routed to OCR
        scanned_pages: List of 0-indexed page numbers that are scanned
        total_pages: Total number of pages in document
        scanned_ratio: Ratio of scanned pages to total pages
    """
    needs_ocr: bool
    scanned_pages: list[int]
    total_pages: int
    scanned_ratio: float


class ScannedDocumentDetector:
    """Detect scanned/image-based pages in PDF documents.

    LOCR-05: Scanned document detection implemented (auto OCR routing)

    Uses text extraction ratio: if extractable characters per page
    is below threshold, the page is likely a scanned image.

    Example:
        detector = ScannedDocumentDetector()
        result = detector.detect(pdf_bytes)
        if result.needs_ocr:
            # Route to GPU OCR or Docling OCR
            ...
    """

    # Minimum characters per page to consider it "native" (has text layer)
    MIN_CHARS_THRESHOLD = 50

    # Ratio of scanned pages to trigger full-document OCR
    SCANNED_PAGE_RATIO_THRESHOLD = 0.5

    def __init__(
        self,
        min_chars_threshold: int = MIN_CHARS_THRESHOLD,
        scanned_ratio_threshold: float = SCANNED_PAGE_RATIO_THRESHOLD,
    ):
        """Initialize detector with configurable thresholds.

        Args:
            min_chars_threshold: Minimum characters per page to consider native
            scanned_ratio_threshold: Ratio of scanned pages to trigger OCR
        """
        self.min_chars_threshold = min_chars_threshold
        self.scanned_ratio_threshold = scanned_ratio_threshold

    def _page_needs_ocr(self, page: pdfium.PdfPage) -> bool:
        """Check if a single page needs OCR.

        Args:
            page: pypdfium2 PdfPage object

        Returns:
            True if page appears to be scanned (needs OCR)
        """
        try:
            textpage = page.get_textpage()
            text = textpage.get_text_bounded()

            # If we extracted meaningful text, page has a text layer
            if text and len(text.strip()) >= self.min_chars_threshold:
                return False

            return True
        except Exception as e:
            # If text extraction fails, assume page is scanned
            logger.warning("Text extraction failed for page, assuming scanned: %s", str(e))
            return True

    def detect(self, pdf_bytes: bytes) -> DetectionResult:
        """Analyze PDF for OCR need.

        LOCR-05: Scanned document detection implemented (auto OCR routing)

        Args:
            pdf_bytes: Raw PDF file bytes

        Returns:
            DetectionResult with needs_ocr flag and page-level details
        """
        if not pdf_bytes:
            logger.warning("Empty PDF bytes provided")
            return DetectionResult(
                needs_ocr=False,
                scanned_pages=[],
                total_pages=0,
                scanned_ratio=0.0,
            )

        try:
            pdf = pdfium.PdfDocument(pdf_bytes)
        except Exception as e:
            logger.error("Failed to parse PDF: %s", str(e))
            # If we can't parse the PDF, assume it needs OCR
            return DetectionResult(
                needs_ocr=True,
                scanned_pages=[],
                total_pages=0,
                scanned_ratio=1.0,
            )

        total_pages = len(pdf)
        if total_pages == 0:
            return DetectionResult(
                needs_ocr=False,
                scanned_pages=[],
                total_pages=0,
                scanned_ratio=0.0,
            )

        scanned_pages: list[int] = []

        for i in range(total_pages):
            page = pdf[i]
            if self._page_needs_ocr(page):
                scanned_pages.append(i)

        # Document needs OCR if majority of pages are scanned
        scanned_ratio = len(scanned_pages) / total_pages
        needs_ocr = scanned_ratio >= self.scanned_ratio_threshold

        logger.info(
            "PDF detection: %d/%d pages scanned (%.1f%%), needs_ocr=%s",
            len(scanned_pages),
            total_pages,
            scanned_ratio * 100,
            needs_ocr,
        )

        return DetectionResult(
            needs_ocr=needs_ocr,
            scanned_pages=scanned_pages,
            total_pages=total_pages,
            scanned_ratio=scanned_ratio,
        )

    def detect_page(self, pdf_bytes: bytes, page_index: int) -> bool:
        """Check if a specific page needs OCR.

        Args:
            pdf_bytes: Raw PDF file bytes
            page_index: 0-indexed page number

        Returns:
            True if page needs OCR
        """
        try:
            pdf = pdfium.PdfDocument(pdf_bytes)
            if page_index < 0 or page_index >= len(pdf):
                logger.warning("Page index %d out of range", page_index)
                return True

            page = pdf[page_index]
            return self._page_needs_ocr(page)
        except Exception as e:
            logger.error("Failed to check page %d: %s", page_index, str(e))
            return True
```

Key implementation notes:
- Use pypdfium2 (already installed via Docling) for PDF text extraction
- MIN_CHARS_THRESHOLD=50 as starting point (configurable)
- SCANNED_PAGE_RATIO_THRESHOLD=0.5 means >50% scanned pages triggers OCR
- DetectionResult dataclass provides structured output
- Both document-level and page-level detection supported
- Error handling returns conservative "needs_ocr=True" on failures
  </action>
  <verify>
`cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr.scanned_detector import ScannedDocumentDetector, DetectionResult; print('imports work')"` succeeds.
  </verify>
  <done>ScannedDocumentDetector with text ratio detection and DetectionResult dataclass</done>
</task>

<task type="auto">
  <name>Task 2: Update OCR module exports</name>
  <files>backend/src/ocr/__init__.py</files>
  <action>
Update the OCR module `__init__.py` to export the new detector:

```python
"""OCR module for scanned document detection and GPU OCR integration.

LOCR-05: Scanned document detection implemented (auto OCR routing)
LOCR-06: LightOnOCRClient in backend communicates with GPU service via HTTP
"""

from src.ocr.lightonocr_client import LightOnOCRClient, LightOnOCRError
from src.ocr.scanned_detector import DetectionResult, ScannedDocumentDetector

__all__ = [
    "DetectionResult",
    "LightOnOCRClient",
    "LightOnOCRError",
    "ScannedDocumentDetector",
]
```
  </action>
  <verify>
`cd /Users/gregorydickson/stackpoint/loan/backend && python -c "from src.ocr import ScannedDocumentDetector, DetectionResult; print('module exports work')"` succeeds.
  </verify>
  <done>OCR module exports updated with ScannedDocumentDetector and DetectionResult</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for ScannedDocumentDetector</name>
  <files>backend/tests/unit/ocr/test_scanned_detector.py</files>
  <action>
Create comprehensive unit tests:

```python
"""Unit tests for ScannedDocumentDetector."""

import pytest
from unittest.mock import MagicMock, patch, PropertyMock

from src.ocr.scanned_detector import DetectionResult, ScannedDocumentDetector


class TestDetectionResult:
    """Tests for DetectionResult dataclass."""

    def test_detection_result_creation(self):
        """DetectionResult stores all fields correctly."""
        result = DetectionResult(
            needs_ocr=True,
            scanned_pages=[0, 2, 4],
            total_pages=5,
            scanned_ratio=0.6,
        )

        assert result.needs_ocr is True
        assert result.scanned_pages == [0, 2, 4]
        assert result.total_pages == 5
        assert result.scanned_ratio == 0.6

    def test_detection_result_empty_document(self):
        """DetectionResult handles empty document."""
        result = DetectionResult(
            needs_ocr=False,
            scanned_pages=[],
            total_pages=0,
            scanned_ratio=0.0,
        )

        assert result.needs_ocr is False
        assert len(result.scanned_pages) == 0


class TestScannedDocumentDetector:
    """Tests for ScannedDocumentDetector."""

    @pytest.fixture
    def detector(self):
        """Create detector with default thresholds."""
        return ScannedDocumentDetector()

    @pytest.fixture
    def custom_detector(self):
        """Create detector with custom thresholds."""
        return ScannedDocumentDetector(
            min_chars_threshold=100,
            scanned_ratio_threshold=0.3,
        )

    def test_init_default_thresholds(self, detector):
        """Default thresholds are set correctly."""
        assert detector.min_chars_threshold == 50
        assert detector.scanned_ratio_threshold == 0.5

    def test_init_custom_thresholds(self, custom_detector):
        """Custom thresholds are set correctly."""
        assert custom_detector.min_chars_threshold == 100
        assert custom_detector.scanned_ratio_threshold == 0.3

    def test_detect_empty_bytes(self, detector):
        """Empty bytes returns needs_ocr=False."""
        result = detector.detect(b"")

        assert result.needs_ocr is False
        assert result.scanned_pages == []
        assert result.total_pages == 0

    @patch("src.ocr.scanned_detector.pdfium.PdfDocument")
    def test_detect_native_pdf(self, mock_pdf_class, detector):
        """Native PDF with text layer returns needs_ocr=False."""
        # Mock a 3-page PDF with good text on all pages
        mock_pdf = MagicMock()
        mock_pdf.__len__ = MagicMock(return_value=3)

        # Create mock pages with text
        mock_pages = []
        for i in range(3):
            mock_page = MagicMock()
            mock_textpage = MagicMock()
            mock_textpage.get_text_bounded.return_value = "A" * 100  # Lots of text
            mock_page.get_textpage.return_value = mock_textpage
            mock_pages.append(mock_page)

        mock_pdf.__getitem__ = MagicMock(side_effect=lambda x: mock_pages[x])
        mock_pdf_class.return_value = mock_pdf

        result = detector.detect(b"fake pdf bytes")

        assert result.needs_ocr is False
        assert result.scanned_pages == []
        assert result.total_pages == 3
        assert result.scanned_ratio == 0.0

    @patch("src.ocr.scanned_detector.pdfium.PdfDocument")
    def test_detect_scanned_pdf(self, mock_pdf_class, detector):
        """Scanned PDF with no text returns needs_ocr=True."""
        # Mock a 3-page PDF with no text on any page
        mock_pdf = MagicMock()
        mock_pdf.__len__ = MagicMock(return_value=3)

        mock_pages = []
        for i in range(3):
            mock_page = MagicMock()
            mock_textpage = MagicMock()
            mock_textpage.get_text_bounded.return_value = ""  # No text
            mock_page.get_textpage.return_value = mock_textpage
            mock_pages.append(mock_page)

        mock_pdf.__getitem__ = MagicMock(side_effect=lambda x: mock_pages[x])
        mock_pdf_class.return_value = mock_pdf

        result = detector.detect(b"fake pdf bytes")

        assert result.needs_ocr is True
        assert result.scanned_pages == [0, 1, 2]
        assert result.total_pages == 3
        assert result.scanned_ratio == 1.0

    @patch("src.ocr.scanned_detector.pdfium.PdfDocument")
    def test_detect_mixed_pdf(self, mock_pdf_class, detector):
        """Mixed PDF with some scanned pages."""
        # Mock a 4-page PDF: pages 0,2 have text, pages 1,3 are scanned
        mock_pdf = MagicMock()
        mock_pdf.__len__ = MagicMock(return_value=4)

        def create_page(has_text):
            mock_page = MagicMock()
            mock_textpage = MagicMock()
            mock_textpage.get_text_bounded.return_value = "A" * 100 if has_text else ""
            mock_page.get_textpage.return_value = mock_textpage
            return mock_page

        mock_pages = [
            create_page(True),   # Page 0: native
            create_page(False),  # Page 1: scanned
            create_page(True),   # Page 2: native
            create_page(False),  # Page 3: scanned
        ]

        mock_pdf.__getitem__ = MagicMock(side_effect=lambda x: mock_pages[x])
        mock_pdf_class.return_value = mock_pdf

        result = detector.detect(b"fake pdf bytes")

        # 50% scanned = exactly at threshold, so needs_ocr=True
        assert result.needs_ocr is True
        assert result.scanned_pages == [1, 3]
        assert result.total_pages == 4
        assert result.scanned_ratio == 0.5

    @patch("src.ocr.scanned_detector.pdfium.PdfDocument")
    def test_detect_below_threshold(self, mock_pdf_class, detector):
        """PDF with scanned pages below threshold returns needs_ocr=False."""
        # Mock a 4-page PDF: 3 native, 1 scanned (25% < 50%)
        mock_pdf = MagicMock()
        mock_pdf.__len__ = MagicMock(return_value=4)

        def create_page(has_text):
            mock_page = MagicMock()
            mock_textpage = MagicMock()
            mock_textpage.get_text_bounded.return_value = "A" * 100 if has_text else ""
            mock_page.get_textpage.return_value = mock_textpage
            return mock_page

        mock_pages = [
            create_page(True),
            create_page(True),
            create_page(True),
            create_page(False),  # Only page 3 is scanned
        ]

        mock_pdf.__getitem__ = MagicMock(side_effect=lambda x: mock_pages[x])
        mock_pdf_class.return_value = mock_pdf

        result = detector.detect(b"fake pdf bytes")

        # 25% < 50% threshold
        assert result.needs_ocr is False
        assert result.scanned_pages == [3]
        assert result.total_pages == 4
        assert result.scanned_ratio == 0.25

    @patch("src.ocr.scanned_detector.pdfium.PdfDocument")
    def test_detect_pdf_parse_error(self, mock_pdf_class, detector):
        """PDF parse error returns needs_ocr=True (conservative)."""
        mock_pdf_class.side_effect = Exception("Invalid PDF")

        result = detector.detect(b"invalid bytes")

        assert result.needs_ocr is True
        assert result.scanned_ratio == 1.0

    @patch("src.ocr.scanned_detector.pdfium.PdfDocument")
    def test_detect_page_specific(self, mock_pdf_class, detector):
        """detect_page checks specific page."""
        mock_pdf = MagicMock()
        mock_pdf.__len__ = MagicMock(return_value=2)

        # Page 0 has text, page 1 is scanned
        mock_page0 = MagicMock()
        mock_textpage0 = MagicMock()
        mock_textpage0.get_text_bounded.return_value = "A" * 100
        mock_page0.get_textpage.return_value = mock_textpage0

        mock_page1 = MagicMock()
        mock_textpage1 = MagicMock()
        mock_textpage1.get_text_bounded.return_value = ""
        mock_page1.get_textpage.return_value = mock_textpage1

        mock_pdf.__getitem__ = MagicMock(side_effect=lambda x: [mock_page0, mock_page1][x])
        mock_pdf_class.return_value = mock_pdf

        assert detector.detect_page(b"fake pdf", 0) is False  # Native
        assert detector.detect_page(b"fake pdf", 1) is True   # Scanned

    @patch("src.ocr.scanned_detector.pdfium.PdfDocument")
    def test_detect_page_out_of_range(self, mock_pdf_class, detector):
        """detect_page returns True for out-of-range page (conservative)."""
        mock_pdf = MagicMock()
        mock_pdf.__len__ = MagicMock(return_value=2)
        mock_pdf_class.return_value = mock_pdf

        assert detector.detect_page(b"fake pdf", 5) is True
        assert detector.detect_page(b"fake pdf", -1) is True

    def test_threshold_boundary(self):
        """Threshold boundary: exactly at threshold triggers OCR."""
        detector = ScannedDocumentDetector(scanned_ratio_threshold=0.5)

        # 50% scanned should trigger OCR (>= threshold)
        with patch("src.ocr.scanned_detector.pdfium.PdfDocument") as mock_pdf_class:
            mock_pdf = MagicMock()
            mock_pdf.__len__ = MagicMock(return_value=2)

            # One scanned, one native = 50%
            def create_page(has_text):
                mock_page = MagicMock()
                mock_textpage = MagicMock()
                mock_textpage.get_text_bounded.return_value = "A" * 100 if has_text else ""
                mock_page.get_textpage.return_value = mock_textpage
                return mock_page

            mock_pages = [create_page(True), create_page(False)]
            mock_pdf.__getitem__ = MagicMock(side_effect=lambda x: mock_pages[x])
            mock_pdf_class.return_value = mock_pdf

            result = detector.detect(b"fake pdf")
            assert result.needs_ocr is True
            assert result.scanned_ratio == 0.5
```

Tests cover:
- DetectionResult dataclass creation
- Default and custom threshold initialization
- Empty bytes handling
- Native PDF detection (all pages have text)
- Scanned PDF detection (no pages have text)
- Mixed PDF detection (some scanned, some native)
- Below-threshold handling
- PDF parse error handling (conservative)
- Page-specific detection
- Out-of-range page handling
- Threshold boundary behavior
  </action>
  <verify>
`cd /Users/gregorydickson/stackpoint/loan/backend && python -m pytest tests/unit/ocr/test_scanned_detector.py -v` - all tests pass.
  </verify>
  <done>Comprehensive unit tests for ScannedDocumentDetector with 14+ test cases</done>
</task>

</tasks>

<verification>
- ScannedDocumentDetector imports without errors
- DetectionResult dataclass works correctly
- Native PDFs correctly identified (needs_ocr=False)
- Scanned PDFs correctly identified (needs_ocr=True)
- Mixed documents handled with configurable threshold
- All tests pass with mocking
</verification>

<success_criteria>
- LOCR-05: Scanned document detection implemented (auto OCR routing)
- pypdfium2 text ratio detection working
- Configurable thresholds (MIN_CHARS_THRESHOLD, SCANNED_PAGE_RATIO_THRESHOLD)
- `cd backend && python -m pytest tests/unit/ocr/test_scanned_detector.py -v` passes
</success_criteria>

<output>
After completion, create `.planning/phases/14-ocr-routing-fallback/14-01-SUMMARY.md`
</output>
