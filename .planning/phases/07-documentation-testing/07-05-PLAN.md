---
phase: 07-documentation-testing
plan: 05
type: execute
wave: 2
depends_on: ["07-04"]
files_modified:
  - backend/pyproject.toml
  - backend/tests/conftest.py
  - backend/src/**/*.py
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "mypy strict mode passes with zero errors across entire backend"
    - "Frontend builds successfully without errors"
    - "Terraform validates successfully"
    - "All quality gates pass"
  artifacts:
    - path: "backend/pyproject.toml"
      provides: "mypy configuration including tests directory"
      contains: ["[tool.mypy]", "strict = true"]
  key_links:
    - from: "mypy"
      to: "backend/src/"
      via: "Type checking all source files"
      pattern: "strict = true"
---

<objective>
Achieve full type safety with mypy strict mode passing across the entire codebase, verify frontend builds, and validate Terraform configuration.

Purpose: Ensure production-quality code with complete type coverage and no configuration errors.

Output: Zero mypy errors in strict mode, successful frontend build, and validated Terraform configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/07-documentation-testing/07-CONTEXT.md
@.planning/phases/07-documentation-testing/07-RESEARCH.md

# Current configuration
@backend/pyproject.toml
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable mypy Strict Mode for Tests and Fix Type Errors</name>
  <files>
    backend/pyproject.toml
    backend/tests/conftest.py
    backend/tests/**/*.py
  </files>
  <action>
Currently mypy excludes tests/ directory. Enable strict checking for tests and fix all type errors.

**Step 1: Update pyproject.toml mypy configuration:**

Change from:
```toml
[tool.mypy]
python_version = "3.12"
strict = true
plugins = ["pydantic.mypy"]
exclude = ["tests/", "alembic/"]
```

To:
```toml
[tool.mypy]
python_version = "3.12"
strict = true
plugins = ["pydantic.mypy"]
exclude = ["alembic/"]

[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false
disallow_untyped_calls = false
disallow_incomplete_defs = false
```

This keeps strict mode for src/ but relaxes some rules for tests (common practice).

**Step 2: Run mypy and identify errors:**
```bash
cd backend
mypy src/ tests/
```

**Step 3: Fix common type error patterns:**

1. **Missing return type annotations:**
   - Add `-> None` for test functions
   - Add explicit return types for fixtures

2. **Untyped mocks:**
   ```python
   # Before
   mock = MagicMock()

   # After
   mock: MagicMock = MagicMock(spec=ActualClass)
   ```

3. **Missing type imports:**
   ```python
   from typing import TYPE_CHECKING
   if TYPE_CHECKING:
       from httpx import AsyncClient
   ```

4. **Fixture type hints:**
   ```python
   @pytest.fixture
   async def client() -> AsyncGenerator[AsyncClient, None]:
       ...
   ```

5. **Any types from third-party libraries:**
   - Use `# type: ignore[import-untyped]` for libraries without stubs
   - Only as last resort, prefer proper typing

**Step 4: Common fixes needed:**
- conftest.py: Add proper return types to fixtures
- test files: May need `# type: ignore[arg-type]` for mock return values
- Ensure all `assert` statements have proper typing
  </action>
  <verify>
```bash
cd backend
mypy src/ tests/ --strict
```
Should complete with zero errors (warnings are acceptable).
  </verify>
  <done>
mypy strict mode enabled for tests directory with all type errors fixed
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix Any Remaining Source Code Type Errors</name>
  <files>backend/src/**/*.py</files>
  <action>
Run mypy on source code and fix any remaining type errors. The source has been developed with strict mode, but verify there are zero errors.

**Step 1: Run mypy on source:**
```bash
cd backend
mypy src/ --strict
```

**Step 2: Common fixes if any errors found:**

1. **Optional handling:**
   ```python
   # Before (error: Item "None" has no attribute "x")
   result = maybe_none.x

   # After
   if maybe_none is not None:
       result = maybe_none.x
   ```

2. **Function overloads for different return types:**
   ```python
   from typing import overload

   @overload
   def get_item(id: str) -> Item: ...
   @overload
   def get_item(id: None) -> None: ...
   def get_item(id: str | None) -> Item | None:
       ...
   ```

3. **TypedDict for JSON responses:**
   ```python
   from typing import TypedDict

   class ResponseDict(TypedDict):
       id: str
       status: str
   ```

4. **Generic types:**
   ```python
   from typing import Sequence

   def process_items(items: Sequence[Item]) -> list[ProcessedItem]:
       ...
   ```

**Step 3: Verify no type: ignore comments without error codes:**
Search for bare `# type: ignore` and add specific error codes:
```bash
grep -r "# type: ignore$" backend/src/
# Should return nothing - all ignores need error codes
```

If found, change to:
```python
# type: ignore[arg-type]
# type: ignore[return-value]
```
  </action>
  <verify>
```bash
cd backend
mypy src/ --strict 2>&1 | grep -c "error:" || echo "0 errors"
# Should output "0 errors" or just "0"
```
  </verify>
  <done>
All source code type errors fixed, mypy strict passes with zero errors on src/
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Frontend Build and Terraform Validation</name>
  <files>
    frontend/package.json
    infrastructure/terraform/
  </files>
  <action>
Verify frontend builds successfully and Terraform configuration validates.

**Step 1: Frontend build verification (TEST-19):**
```bash
cd frontend
npm run build
```

If build fails, common fixes:
- TypeScript errors: Fix type annotations in components
- Import errors: Verify all imports exist
- Next.js config errors: Check next.config.js

**Step 2: Frontend type checking:**
```bash
cd frontend
npx tsc --noEmit
```

Fix any TypeScript errors in frontend code.

**Step 3: Terraform validation (TEST-20):**
```bash
cd infrastructure/terraform
terraform init -backend=false
terraform validate
```

If validation fails:
- Fix syntax errors in .tf files
- Ensure all required variables have defaults or are marked optional
- Verify resource references are correct

**Step 4: Run all quality checks in sequence:**
```bash
# Backend quality
cd backend
mypy src/ tests/ --strict
pytest --cov=src --cov-fail-under=80
ruff check src/

# Frontend quality
cd frontend
npm run build

# Infrastructure quality
cd infrastructure/terraform
terraform validate
```

**Step 5: Document final coverage:**
```bash
cd backend
pytest --cov=src --cov-report=term-missing | tee coverage-report.txt
```
  </action>
  <verify>
```bash
# All these should succeed
cd backend && mypy src/ tests/ --strict && echo "mypy: PASS"
cd frontend && npm run build && echo "frontend build: PASS"
cd infrastructure/terraform && terraform validate && echo "terraform: PASS"
cd backend && pytest --cov=src --cov-fail-under=80 && echo "coverage: PASS"
```
  </verify>
  <done>
All quality gates pass: mypy strict (0 errors), frontend build (success), Terraform validate (success), coverage (>80%)
  </done>
</task>

</tasks>

<verification>
1. `mypy src/ tests/ --strict` passes with zero errors
2. `npm run build` succeeds in frontend directory
3. `terraform validate` succeeds in infrastructure/terraform
4. `pytest --cov=src --cov-fail-under=80` passes
5. Covers requirements TEST-17 through TEST-20
</verification>

<success_criteria>
- mypy strict mode passes with zero errors across backend/src/ and backend/tests/
- Frontend builds successfully with `npm run build`
- Terraform configuration validates successfully
- All quality gates (mypy, coverage, build, validate) pass in a single run
</success_criteria>

<output>
After completion, create `.planning/phases/07-documentation-testing/07-05-SUMMARY.md`
</output>
