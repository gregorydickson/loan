---
phase: 09-cloud-tasks-background-processing
plan: 04
type: execute
wave: 4
depends_on: ["09-03"]
files_modified:
  - backend/tests/unit/test_cloud_tasks_client.py
  - backend/tests/integration/test_async_processing.py
  - backend/tests/integration/conftest.py
autonomous: true

must_haves:
  truths:
    - "CloudTasksClient unit tests verify task creation with OIDC"
    - "Integration tests verify async upload returns PENDING"
    - "Sync fallback tests verify local dev still works"
    - "Task handler integration tests verify document processing"
  artifacts:
    - path: "backend/tests/unit/test_cloud_tasks_client.py"
      provides: "Unit tests for CloudTasksClient"
      min_lines: 50
    - path: "backend/tests/integration/test_async_processing.py"
      provides: "Integration tests for async document processing"
      min_lines: 80
  key_links:
    - from: "backend/tests/unit/test_cloud_tasks_client.py"
      to: "src.ingestion.cloud_tasks_client"
      via: "test imports"
      pattern: "from src.ingestion.cloud_tasks_client import"
---

<objective>
Add comprehensive tests for Cloud Tasks background processing

Purpose: Ensure the async processing flow works correctly with proper test coverage for both the CloudTasksClient and the end-to-end async flow.

Output: Unit tests for CloudTasksClient and integration tests for async document processing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-cloud-tasks-background-processing/09-RESEARCH.md
@.planning/phases/09-cloud-tasks-background-processing/09-03-SUMMARY.md

# Test patterns
@backend/tests/integration/conftest.py
@backend/tests/integration/test_e2e_extraction.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CloudTasksClient unit tests</name>
  <files>backend/tests/unit/test_cloud_tasks_client.py</files>
  <action>
Create backend/tests/unit/test_cloud_tasks_client.py:

```python
"""Unit tests for CloudTasksClient."""

from __future__ import annotations

import json
from unittest.mock import MagicMock, patch
from uuid import UUID

import pytest


class TestCloudTasksClient:
    """Tests for CloudTasksClient task creation."""

    @pytest.fixture
    def mock_tasks_client(self):
        """Mock google.cloud.tasks_v2.CloudTasksClient."""
        with patch("src.ingestion.cloud_tasks_client.tasks_v2") as mock_tasks:
            mock_client = MagicMock()
            mock_tasks.CloudTasksClient.return_value = mock_client
            mock_client.queue_path.return_value = (
                "projects/test-project/locations/us-central1/queues/test-queue"
            )

            # Mock the task creation response
            mock_task = MagicMock()
            mock_task.name = "projects/test-project/locations/us-central1/queues/test-queue/tasks/123"
            mock_client.create_task.return_value = mock_task

            yield mock_tasks, mock_client

    def test_init_creates_client_with_queue_path(self, mock_tasks_client):
        """Test CloudTasksClient initializes with correct queue path."""
        mock_tasks, mock_client = mock_tasks_client

        from src.ingestion.cloud_tasks_client import CloudTasksClient

        client = CloudTasksClient(
            project_id="test-project",
            location="us-central1",
            queue_id="test-queue",
            service_url="https://backend.example.com",
            service_account_email="sa@test-project.iam.gserviceaccount.com",
        )

        mock_client.queue_path.assert_called_once_with(
            "test-project", "us-central1", "test-queue"
        )
        assert client.service_url == "https://backend.example.com"
        assert client.service_account_email == "sa@test-project.iam.gserviceaccount.com"

    def test_init_strips_trailing_slash_from_service_url(self, mock_tasks_client):
        """Test service URL has trailing slash removed."""
        mock_tasks, mock_client = mock_tasks_client

        from src.ingestion.cloud_tasks_client import CloudTasksClient

        client = CloudTasksClient(
            project_id="test-project",
            location="us-central1",
            queue_id="test-queue",
            service_url="https://backend.example.com/",
            service_account_email="sa@test-project.iam.gserviceaccount.com",
        )

        assert client.service_url == "https://backend.example.com"

    def test_create_document_processing_task(self, mock_tasks_client):
        """Test task creation with correct payload and OIDC token."""
        mock_tasks, mock_client = mock_tasks_client

        from src.ingestion.cloud_tasks_client import CloudTasksClient

        client = CloudTasksClient(
            project_id="test-project",
            location="us-central1",
            queue_id="test-queue",
            service_url="https://backend.example.com",
            service_account_email="sa@test-project.iam.gserviceaccount.com",
        )

        document_id = UUID("12345678-1234-5678-1234-567812345678")
        task = client.create_document_processing_task(
            document_id=document_id,
            filename="test.pdf",
        )

        # Verify create_task was called
        mock_client.create_task.assert_called_once()
        call_args = mock_client.create_task.call_args

        # Extract the task from the CreateTaskRequest
        request = call_args[0][0]
        task_proto = request.task

        # Verify HTTP request configuration
        http_request = task_proto.http_request
        assert http_request.url == "https://backend.example.com/api/tasks/process-document"
        assert http_request.headers["Content-Type"] == "application/json"

        # Verify payload
        payload = json.loads(http_request.body.decode())
        assert payload["document_id"] == str(document_id)
        assert payload["filename"] == "test.pdf"

        # Verify OIDC token
        assert http_request.oidc_token.service_account_email == "sa@test-project.iam.gserviceaccount.com"
        assert http_request.oidc_token.audience == "https://backend.example.com"

    def test_create_task_returns_task_object(self, mock_tasks_client):
        """Test that create_document_processing_task returns the created task."""
        mock_tasks, mock_client = mock_tasks_client

        from src.ingestion.cloud_tasks_client import CloudTasksClient

        client = CloudTasksClient(
            project_id="test-project",
            location="us-central1",
            queue_id="test-queue",
            service_url="https://backend.example.com",
            service_account_email="sa@test-project.iam.gserviceaccount.com",
        )

        document_id = UUID("12345678-1234-5678-1234-567812345678")
        result = client.create_document_processing_task(
            document_id=document_id,
            filename="test.pdf",
        )

        assert result.name == "projects/test-project/locations/us-central1/queues/test-queue/tasks/123"
```

Key test coverage:
- Client initialization with queue path
- Trailing slash handling on service URL
- Task creation with correct payload
- OIDC token configuration
- Return value verification
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && pytest tests/unit/test_cloud_tasks_client.py -v`
  </verify>
  <done>CloudTasksClient has comprehensive unit tests</done>
</task>

<task type="auto">
  <name>Task 2: Create async processing integration tests</name>
  <files>backend/tests/integration/test_async_processing.py</files>
  <action>
Create backend/tests/integration/test_async_processing.py:

```python
"""Integration tests for async document processing with Cloud Tasks."""

from __future__ import annotations

from unittest.mock import MagicMock, patch
from uuid import uuid4

import pytest
from httpx import ASGITransport, AsyncClient

from src.main import app
from src.storage.models import DocumentStatus


@pytest.fixture
def mock_cloud_tasks_client():
    """Mock CloudTasksClient for testing async flow."""
    mock_client = MagicMock()
    mock_task = MagicMock()
    mock_task.name = "projects/test/locations/us-central1/queues/doc-processing/tasks/123"
    mock_client.create_document_processing_task.return_value = mock_task
    return mock_client


@pytest.fixture
async def client_with_async_upload(
    test_db_session,
    mock_docling_processor,
    mock_borrower_extractor,
    mock_cloud_tasks_client,
):
    """Test client configured for async upload testing."""
    from src.api.dependencies import (
        get_borrower_extractor,
        get_borrower_repository,
        get_cloud_tasks_client,
        get_docling_processor,
        get_document_repository,
        get_gcs_client,
    )
    from src.storage.repositories import BorrowerRepository, DocumentRepository

    def override_document_repo():
        return DocumentRepository(test_db_session)

    def override_borrower_repo():
        return BorrowerRepository(test_db_session)

    def override_gcs_client():
        mock_gcs = MagicMock()
        mock_gcs.upload.return_value = "gs://test-bucket/test-path"
        mock_gcs.download.return_value = b"mock content"
        mock_gcs.bucket_name = "test-bucket"
        return mock_gcs

    def override_docling_processor():
        return mock_docling_processor

    def override_borrower_extractor():
        return mock_borrower_extractor

    def override_cloud_tasks_client():
        return mock_cloud_tasks_client

    app.dependency_overrides[get_document_repository] = override_document_repo
    app.dependency_overrides[get_borrower_repository] = override_borrower_repo
    app.dependency_overrides[get_gcs_client] = override_gcs_client
    app.dependency_overrides[get_docling_processor] = override_docling_processor
    app.dependency_overrides[get_borrower_extractor] = override_borrower_extractor
    app.dependency_overrides[get_cloud_tasks_client] = override_cloud_tasks_client

    async with AsyncClient(
        transport=ASGITransport(app=app),
        base_url="http://test",
    ) as client:
        yield client, mock_cloud_tasks_client

    app.dependency_overrides.clear()


@pytest.mark.integration
class TestAsyncUpload:
    """Tests for async document upload flow."""

    async def test_upload_with_cloud_tasks_returns_pending(
        self,
        client_with_async_upload,
    ):
        """Test that upload with Cloud Tasks configured returns PENDING status."""
        client, mock_tasks = client_with_async_upload

        # Create test file
        files = {"file": ("test.pdf", b"fake pdf content", "application/pdf")}

        response = await client.post("/api/documents/", files=files)

        assert response.status_code == 201
        data = response.json()

        # Should return PENDING since we're using Cloud Tasks
        assert data["status"] == "pending"
        assert "queued for processing" in data["message"].lower()

        # Verify task was created
        mock_tasks.create_document_processing_task.assert_called_once()
        call_args = mock_tasks.create_document_processing_task.call_args
        assert call_args.kwargs["filename"] == "test.pdf"

    async def test_upload_creates_document_record(
        self,
        client_with_async_upload,
        test_db_session,
    ):
        """Test that document record is created before task is queued."""
        client, mock_tasks = client_with_async_upload

        files = {"file": ("test.pdf", b"fake pdf content", "application/pdf")}

        response = await client.post("/api/documents/", files=files)

        assert response.status_code == 201
        document_id = response.json()["id"]

        # Verify document exists in database
        from src.storage.repositories import DocumentRepository

        repo = DocumentRepository(test_db_session)
        document = await repo.get_by_id(document_id)

        assert document is not None
        assert document.status == DocumentStatus.PENDING
        assert document.filename == "test.pdf"


@pytest.mark.integration
class TestTaskHandler:
    """Tests for Cloud Tasks handler endpoint."""

    async def test_process_document_endpoint_exists(self, client):
        """Test that process-document endpoint is registered."""
        # Just verify the endpoint exists (will return 422 without valid payload)
        response = await client.post(
            "/api/tasks/process-document",
            json={},
        )

        # Should be 422 (validation error) not 404
        assert response.status_code == 422

    async def test_process_document_with_missing_document(
        self,
        client,
    ):
        """Test handler returns success for missing document (no retry)."""
        response = await client.post(
            "/api/tasks/process-document",
            json={
                "document_id": str(uuid4()),
                "filename": "test.pdf",
            },
        )

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "failed"
        assert "not found" in data["error"].lower()


@pytest.mark.integration
class TestSyncFallback:
    """Tests for sync processing fallback (local development)."""

    async def test_upload_without_cloud_tasks_processes_sync(
        self,
        client_with_extraction,
    ):
        """Test that upload without Cloud Tasks config processes synchronously."""
        client = client_with_extraction

        files = {"file": ("test.pdf", b"fake pdf content", "application/pdf")}

        response = await client.post("/api/documents/", files=files)

        assert response.status_code == 201
        data = response.json()

        # Should return COMPLETED since sync processing runs
        assert data["status"] == "completed"
        assert data["page_count"] is not None
```

Key test coverage:
- Async upload returns PENDING immediately
- Document record created before task queued
- Task handler endpoint exists and handles missing documents
- Sync fallback works for local development
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && pytest tests/integration/test_async_processing.py -v -m integration`
  </verify>
  <done>Async processing has comprehensive integration tests</done>
</task>

<task type="auto">
  <name>Task 3: Update conftest.py with async fixtures</name>
  <files>backend/tests/integration/conftest.py</files>
  <action>
Update backend/tests/integration/conftest.py to add fixtures for async testing:

Add these imports at the top if not present:
```python
from unittest.mock import MagicMock
```

Add fixture for testing task handler directly:
```python
@pytest.fixture
async def client_with_task_handler(
    test_db_session,
    mock_docling_processor,
    mock_borrower_extractor_with_data,
):
    """Test client for task handler testing with real document processing."""
    from src.api.dependencies import (
        get_borrower_extractor,
        get_borrower_repository,
        get_cloud_tasks_client,
        get_docling_processor,
        get_document_repository,
        get_gcs_client,
    )
    from src.storage.repositories import BorrowerRepository, DocumentRepository

    def override_document_repo():
        return DocumentRepository(test_db_session)

    def override_borrower_repo():
        return BorrowerRepository(test_db_session)

    def override_gcs_client():
        mock_gcs = MagicMock()
        mock_gcs.upload.return_value = "gs://test-bucket/test-path"
        mock_gcs.download.return_value = b"mock pdf content"
        mock_gcs.bucket_name = "test-bucket"
        return mock_gcs

    def override_docling_processor():
        return mock_docling_processor

    def override_borrower_extractor():
        return mock_borrower_extractor_with_data

    def override_cloud_tasks_client():
        # Return None to simulate local dev (no async queueing)
        return None

    app.dependency_overrides[get_document_repository] = override_document_repo
    app.dependency_overrides[get_borrower_repository] = override_borrower_repo
    app.dependency_overrides[get_gcs_client] = override_gcs_client
    app.dependency_overrides[get_docling_processor] = override_docling_processor
    app.dependency_overrides[get_borrower_extractor] = override_borrower_extractor
    app.dependency_overrides[get_cloud_tasks_client] = override_cloud_tasks_client

    async with AsyncClient(
        transport=ASGITransport(app=app),
        base_url="http://test",
    ) as test_client:
        yield test_client

    app.dependency_overrides.clear()
```

Note: This fixture extends the existing pattern from client_with_extraction but explicitly sets cloud_tasks_client to None for sync testing.
  </action>
  <verify>
Run: `cd /Users/gregorydickson/stackpoint/loan/backend && pytest tests/integration/ -v -m integration --collect-only | grep -E "(test_|fixture)"` to verify fixtures are recognized
  </verify>
  <done>Conftest.py has fixtures for async and sync processing tests</done>
</task>

</tasks>

<verification>
1. Unit tests pass: `pytest tests/unit/test_cloud_tasks_client.py -v`
2. Integration tests pass: `pytest tests/integration/test_async_processing.py -v -m integration`
3. Existing E2E tests still pass: `pytest tests/integration/test_e2e_extraction.py -v -m integration`
4. Overall test coverage maintained: `pytest --cov=src --cov-report=term-missing`
</verification>

<success_criteria>
- All new tests pass
- Existing tests still pass (no regressions)
- Test coverage >= 80% maintained
- `pytest tests/ -v -m integration` shows new async tests
</success_criteria>

<output>
After completion, create `.planning/phases/09-cloud-tasks-background-processing/09-04-SUMMARY.md`
</output>
